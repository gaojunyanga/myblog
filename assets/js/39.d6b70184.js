(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{464:function(a,n,e){"use strict";e.r(n);var s=e(2),t=Object(s.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"自我介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[a._v("#")]),a._v(" 自我介绍")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(" 你好，我叫xxx，今年25岁，毕业于安阳工学院，在校期间所学的专业是软件技术。我的上一家公司在北京远浪科技有限公司，我在这个公司待了有三年时间，主要是负责公司产品的后台功能研发，我的主要工作内容是 后台接口功能的实现 有的时候 还会参与接口文档的编写  时序图绘制  配合项目经理 完成项目经理分配的一些任务。我们小组有7个开发， 2个前端，4个后台，一个项目经理。在职期间参与过三个项目的研发，最近做的是宏源金融平台，主要涉及贷款、支付、商家服务等功能。去年年初做的是云鲸在线教育平台，是一个在线教育类的产品 b2b2c模式，再早一点做的是一个医院的项目，主要功能是在线预约。个人情况，大概就是这样的。\n")])])]),n("h2",{attrs:{id:"项目话术"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目话术"}},[a._v("#")]),a._v(" 项目话术")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("最近做的是一个金融类的项目，它是一个SaaS平台，让商家租用我们的软件功能，提供不用的套餐，主要是以这种模式来进行盈利，当然这个平台还可以挂一些广告，比如一些电商网站的链接，一些商品厂家的广告。\n\n平台主要包括三个模块：官网&开放平台、商户平台、运营平台。\n我主要负责的是商户平台的商家入驻和支付模块\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("商户入驻指的是我们推广人员去与商户谈合作，这个商户可以是线上的也可以是线下的，以线下来举例，市场人员会拿着这个平台的物料比如音响收款码的框，扫码枪，去和线下商家谈， 推广。如果商家愿意入住，推广人员会帮助商家进行入驻和资质申请，需要先入驻在进行资质申请。商户入驻功能 涉及后台商户应用平台，商户服务，通信服务，saas服务（网关 认证服务  用户服务） 等，整个流程是 商户注册发送验证码，校验通过保存商户手机号到商户表在saaS 平台，并且初始化租户(商户)的默认套餐(套餐包含商户的账号权限等信息)还有初始化根门店和员工信息，商户入驻成功之后商户表会有商户的手机号，资质状态等信息，然后需要根据入驻的账号 登录    \n\n补充说明：商户的概念和租户的概念是一一对应的，但是 商户 租户 不等同于 账户（用户），商户和租户可以理解为是一个团体机构，账号针对的是 这个租户下的个体员工，比如第一个注册的用户，默认就是老板。员工注册会在商户平台存储员工信息 会在 saas平台的用户服务中 保存账号信息。员工登录 功能  我们使用的是 saas提供的认证服务，其底层是 spring security + oauth2 + jwt ，  使用的是 密码认证模式 ，员工输入账号密码  认证服务进行认证 认证通过 返回令牌token ，后续 用户访问功能需要携带令牌，到网关 进行鉴权校验，认证通过放行。\n\n登陆之后  才能进行资质申请\n推广人员帮助商户进行资质认证，资质认证需要上传商户的营业执照身份证正反面等信息，由运营平台审核相关信息的真实性。如果资质认证通过商户才可以使用平台的相关功能。     现在我们部门正在优化这个功能，现在资质还需要  商家拿着身份证拍照上传。\n\n资质申请通过后   需要创建应用，这个应用是商家在支付业务中的一个标识，一个商家可以创建多个应用，比如 商家涉及的业务比较多，有超市，有饭店等，  每个应用可以开通 支付平台的多种服务类型  ， 平台的服务类型 可以分为 线上支付 和 线下支付，线下支付又可以分为 B2C ，C2B，等支付模式 ，确定了应用，门店服务类型之后 ，就可以给商家生成门店二维码，然后 配置具体的支付渠道参数，这个支付渠道参数是一个json格式的，存储在数据库就是一个字符串，这样就可以在一个表里存储zfb、微信等第三方支付方式。\n（保存支付渠道参数这里还碰到了个小插曲，因为渠道参数查询频繁，每一次支付都会查询渠道参数，为提供查询性能我便将渠道参数缓存到redis中，查询渠道参数的话，先从Redis查询，如果Redis存在则返回渠道参数，否则从数据库查询同时将查询到的渠道参数存储在Redis中。但是当时测试的时候报了个栈溢出的错误，然后最后分析发现莫名写了个递归。我当时写的是先查询redis，redis没有就查询数据库，查询完数据库更新缓存到redis，错就错在这个更新缓存到redis方法，这个更新缓存方法里面我又加了判断调了一下上面的查询方法，导致进入了一个闭环。最后解决方法就是打断这个链，更新缓存这个方法，直接用核心代码代替，就不会出现递归调用。）\n\n\n支付模块，商户资质申请通过需要给商户生成收款码，商户要给选择的某个门店生成收款码，这个收款码是一个聚合的收款码，对应一个平台支付接口的地址，使用第三方支付可以请求 平台的支付接口， 返回一个表单页面，表单页面上会显示商家订单等信息。\n\n这个页面 使用的是 freemarker 让平台数据回显，点击立即支付会请求交易服务的接口，交易服务这个接口会实现商户应用本地订单的创建，调用 支付渠道代理服务，（我们在 交易服务 准备好 支付宝支付接口 需要的参数，参数大致分两类，一类是 应用私钥 支付宝公钥 支付宝网关地址这类 支付渠道参数，一类是 业务参数 比如 商品名称商家名称 支付金额等。然后 调用 支付渠道代理服务 完成支付）实现第三方支付接口的调用，交易服务的这个接口 会返回 支付宝的支付页面，顾客输入支付宝的密码 完成支付，页面跳转回平台的一些广告推广页面，做引流\n\n支付结果要同步到我们的平台的订单表中，支付之后，会发送延迟消息查询支付宝的支付结果接口,  这里我一开始打算使用的是Rabbit MQ,但是发现消息延迟发送多少秒都不合适，不确定用户输入密码提交支付的速度，所以用到了另一种消息队列叫Rocket MQ,他的其中一个特点就是支持指定次数和时间间隔的失败消息重发，重复发送消息非常适合现在这个场景，根据第三方支付查询得到的结果，平台去更改订单的状态，然后触发 小音箱  报告支付结果。\n")])])]),n("h2",{attrs:{id:"项目中的技术点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目中的技术点"}},[a._v("#")]),a._v(" 项目中的技术点")]),a._v(" "),n("h3",{attrs:{id:"_1-项目采用了什么技术架构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-项目采用了什么技术架构"}},[a._v("#")]),a._v(" 1.项目采用了什么技术架构？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("\n采用当前流行的前后端分离架构开发，由用户层、UI层、微服务层、数据层等部分组成，为PC、H5等客\n户端用户提供服务\n\n业务流程举例：\n1、用户可以通过PC、手机等客户端访问闪聚支付。\n2、 系统应用CDN技术，对一些图片、CSS、视频等资源从CDN调度访问。\n3、所有的请求全部经过负载均衡器。\n4、首先请求UI层，渲染用户界面。\n5、商户通过平台进行注册和企业认证，UI层通过网关请求服务层，服务层完成业务处理后将数据持久化到数据\n层。\n6、平台运营人员对商户信息进行审核，其系统执行流程和商户注册过程一致，UI层请求服务层业务处理，服务层\n通过数据层将数据持久化到数据库。\n")])])]),n("h4",{attrs:{id:"_2-1-微服务技术栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-微服务技术栈"}},[a._v("#")]),a._v(" 2.1 微服务技术栈")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("所有微服务基于Spring Boot、Spring Cloud Alibaba构建。\n1）控制层：\nSpring MVC、Swagger\n2）业务层：\n事务控制：Spring\n数据缓存：Spring Data Redis\n消息队列：Spring RocketTemplate\n3) 持久层：\nMySQL数据库\nMyBatisPlus持久层框架\n连接池com.alibaba.druid（采用druid-spring-boot-starter）\nShardingJdbc分库分表技术\n宏源金融平台基于Spring Boot构建，采用Spring Cloud Alibaba微服务架构。\n1）基础设施\n业务数据持久化采用MySQL，数据缓存采用Redis，采用RocketMQ的事务消息机制完成部分场景下的分布式事务\n控制，采用第三方云平台完成文件上传与分布式存储。\n2）组件\n系统微服务基于SpringBoot开发，服务层基于Dubbo Spring Cloud构建，数据库连接池采用Druid，POJO构建采\n用Lombok，日志系统采用Log4j2，Mybatis Plus持久层接口实现，Sharding-jdbc分库分表组件，Swagger接口规\n范组件，XXL-job分布式任务调度组件，Sentinel限流组件等。\n3）接入\nZuul网关完成客户端认证、路由转发等功能，JWT提供前后端令牌管理方案。\n4）视图\n平台支持H5、PC等各种前端。\n")])])]),n("h4",{attrs:{id:"_2-2-接口定义规范"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-接口定义规范"}},[a._v("#")]),a._v(" 2.2 接口定义规范")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、项目面向前端的Http接口使用swagger文档描述接口的内容\n2、面向前端的Http接口定义规范如下：\n1）请求\nGet 请求时，前端请求key/value串，SpringMVC采用基本数据类型（String、Integer等）接收参数，特殊情况使\n用自定义对象接收。\nPost请求时，前端请Form表单数据（application/x-www-form-urlencoded）和Json数据(Content-Type=application/json)、多部件类型数据（multipart/form-data），SpringMVC采用基本类型及自定义对象接\n收，对于Json数据SpringMVC使用@RequestBody注解解析请求的json数据。\n\n2）响应\n响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。\n响应结果统一格式为json，扫码类接口为text/html。\n")])])]),n("h4",{attrs:{id:"_2-3-swagger如何使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-swagger如何使用"}},[a._v("#")]),a._v(" 2.3 Swagger如何使用？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务\n(https://swagger.io/)。 它的主要作用是：\n1、使得前后端分离开发更加方便，有利于团队协作\n2、接口的文档在线自动生成，降低后端开发人员编写接口文档的负担\n3、如何使用？\n项目中SpringBoot集成Swagger，Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫\nSpringfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。\n在Controller接口方法上使用注解描述接口内容，Swagger常用注解如下：\n@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口\n@ApiParam：单个参数的描述信息\n@ApiModel：用对象来接收参数\n@ApiModelProperty：用对象接收参数时，描述对象的一个字段\n@ApiResponse：HTTP响应其中1个描述\n@ApiResponses：HTTP响应整体描述\n@ApiIgnore：使用该注解忽略这个API\n@ApiError ：发生错误返回的信息\n@ApiImplicitParam：一个请求参数\n@ApiImplicitParams：多个请求参数的描述信息\n")])])]),n("h4",{attrs:{id:"_2-4-注册中心-服务发现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-注册中心-服务发现"}},[a._v("#")]),a._v(" 2.4 注册中心&服务发现")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目采用Nacos作为注册中心，注册中心也叫服务发现中心，服务发现就是服务消费方通过服务发现中心智能发现\n服务提供方，从而进行远程调用的过程。\n\n（1）在每个服务启动时会向服务发现中心上报自己的网络位置。这样，在服务发现中心内部会形成一个服务注册\n表，服务注册表是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。\n（2）服务发现客户端会定期从服务发现中心同步服务注册表 ，并缓存在客户端。\n（3）当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地\n址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。\n")])])]),n("h4",{attrs:{id:"_2-5-配置中心"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-配置中心"}},[a._v("#")]),a._v(" 2.5 配置中心")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目采用Nacos作为配置中心，配置中心将配置从各应用中剥离出来，对配置进行统一管理，应用自身不需要自己\n去管理配置。\n\n配置中心的服务流程如下：\n1、用户在配置中心更新配置信息。\n2、服务A和服务B及时得到配置更新通知，从配置中心获取配置。\n总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。\n在Nacos中每个微服务对应一个主配置文件，配置文件的名称即服务名加文件扩展名。\n\nNacos重要的概念：\nNacos抽象定义了Namespace、Group、Data ID的概念，具体这几个概念代表什么，取决于我们把它们看成什\n么，这里推荐给大家一种用法，如下图：\nNamespace：代表不同环境，如开发、测试、生产环境。\n项目的bootstrap.yml中别忘记配置Namespace！！！\nGroup：代表某项目，如XX医疗项目、XX电商项目\nDataId：每个项目下往往有若干个工程，每个配置集(DataId)是一个工程的主配置文件\n")])])]),n("h4",{attrs:{id:"_2-6-网关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-网关"}},[a._v("#")]),a._v(" 2.6 网关")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("需要了解网关的作用：负载均衡、路由转发、请求过虑等。\n")])])]),n("h4",{attrs:{id:"_2-7-项目使用spring了吗-用了它的哪些东西"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-项目使用spring了吗-用了它的哪些东西"}},[a._v("#")]),a._v(" 2.7 项目使用Spring了吗？用了它的哪些东西？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目是基于Spring进行构建，每一层都需要Spring。\n1、每个微服务工程是采用Spring Boot开发。\n2、基于Spring Cloud Alibaba实现微服务的配置、服务注册、Dubbo接口。\n其中，最重要的是实现了Dubbo接口与RESTful接口均可以注册至Nacos。\n3、数据层使用MyBatis Plus、Spring RocketMQ、Spring Data redis。\n4、业务层使用Spring来控制本地事务。\n5、控制层使用SpringMVC开发RESTful接口。\n")])])]),n("h4",{attrs:{id:"_2-8-spring-cloud-alibaba是怎么使用的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-spring-cloud-alibaba是怎么使用的"}},[a._v("#")]),a._v(" 2.8 Spring Cloud Alibaba是怎么使用的？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Spring Cloud Alibaba是阿里巴巴公司基于Spring Cloud标准实现的一套微服务开发框架集合，它和Netflix一样都\n是Spring Cloud微服务开发实现方案。\n\n系统的微服务分为两类：应用层服务和业务层服务。\n应用层服务对前端暴露RESTful接口，业务层服务供应用层调用，暴露Dubbo服务。\n1、每个应用层服务使用Spring Boot开发，每个微服务工程包括了web、service、dao三层，这和开发一般的项目\n没有区别：\na、Web层使用Spring MVC实现，对外暴露RESTful接口供前端调用。\nb、Service层就是根据业务逻辑编写JavaBean，并使用Spring的声明式事务控制方式来控制事务。\nc、Dao层就是数据访问接口，使用MybatisPlus访问MySQL。\n2、每个业务层服务通常只需要编写Service和Dao即可，Service暴露为Dubbo服务接口供应用层调用。（特殊情况\n除外，比如交易服务暴露支付入口HTTP接口）\nDubbo接口如何开发？\n和开发一个普通的Service Bean一样，需要在Service类上使用@org.apache.dubbo.config.annotation.Service注\n解。\n3、微服务开发完成要向Nacos注册中心注册，以便被其它微服务查找和访问。\n4、微服务与微服务之间使用Dubbo来调用。只需要在调用方使用\n@org.apache.dubbo.config.annotation.Reference注解引入服务接口，通过生成代理对象发起远程调用。\n5、前端访问微服务需要通过网关，网关使用Nginx和Zuul来实现，Nginx是最前边的负载均衡，通过Nginx之后便\n到达了Zuul，项目中Zuul的功能是过虑用户请求，判断用户身份，对于一些对外公开的微服务则需要经过Zuul，直\n接通过Nginx负载均衡即可访问。\n\n")])])]),n("h4",{attrs:{id:"_2-9-视图层用什么技术实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-视图层用什么技术实现"}},[a._v("#")]),a._v(" 2.9 视图层用什么技术实现？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、从系统整体架构上来说，视图层包括前端视图和服务端视图。\n2、前端视图采用vue.js+elementUI产品界面。\n3、服务端提供给vue前端的都是暴露的RESTful接口，统一用JSON响应数据。\n4、交易服务对外提供支付入口，使用Freemarker视图渲染技术生成HTML页面返回给浏览器。\n")])])]),n("h4",{attrs:{id:"_2-10-接口是怎么定义的-采用什么数据格式-如何实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-接口是怎么定义的-采用什么数据格式-如何实现"}},[a._v("#")]),a._v(" 2.10 接口是怎么定义的？采用什么数据格式？如何实现？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("接口分为面向前端的HTTP接口，和面向服务内部调用的Dubbo服务接口。\n1、面向前端的RESTful接口\n参考2.2 接口定义规范.\n2、面向服务内部采用Dubbo服务接口\n1）采用Dubbo协议具体使用Hessian2 二进制序列化协议。\n2）编写Service类及方法，并使用@org.apache.dubbo.config.annotation.Service注解在类上标识。\n3）Service类需要操作数据库时则通过调用Dao层的Mapper接口来完成。\n4）Service与Service之间的调用分为本地调用和远程调用\n本地调用是同一个工程的service之间的调用，只需要使用@Autowired或@Resource注入即可使用。\n远程调用是跨服务（工程）的service之间的调用，需要在调用方使用\n@org.apache.dubbo.config.annotation.Reference注解引入服务接口，通过生成代理对象发起远程调用。\n\n")])])]),n("h4",{attrs:{id:"_2-11-项目中的代码是否自动生成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-11-项目中的代码是否自动生成"}},[a._v("#")]),a._v(" 2.11 项目中的代码是否自动生成？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目中使用Mybatis-Plus提供的代码自动生成方法来生成代码。\n自动生成的代码包括：entity、DTO、mapper（java、xml）等。\n")])])]),n("h4",{attrs:{id:"_2-12-前端采用什么技术栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-12-前端采用什么技术栈"}},[a._v("#")]),a._v(" 2.12 前端采用什么技术栈？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("前端工程大多为单页面应用（SPA），采用vue.js框架开发，搜索功能前端采用nuxt.js服务端渲染（SSR）框架开\n发。\n技术栈包括：\n1、node.js\n2、vue.js\n3、npm/cnpm\n4、webpack\n5、axios\n6、nuxt.js\n")])])]),n("h3",{attrs:{id:"_3-前后端开发时具体流程是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-前后端开发时具体流程是什么"}},[a._v("#")]),a._v(" 3 前后端开发时具体流程是什么？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("前后端分离开发模式在互联网公司最常见，特别是一些大型的互联网公司，但是一些传统的软件开发企业仍然是采\n用传统开发模式，此问题被问及是考察你有没有真正体会前端开发的好处。\n1、前端与后端开发人员讨论确定接口。\n接口讨论通过，形成接口文档 。\n本项目专门设立一个api工程，在此工程定义接口，Spring Boot 集成Swagger，生成Swagger接口，前后端 开发\n人员通过html查看接口文档的内容。\n2、前端与后端开发人员按照接口文档进行开发。\n开发过程中各自进行单元测试。\n前端人员怎么进行单元测试？\n前端人员可以通过mock平台生成一些模拟数据，比如：EasyMock。\n有兴趣的同学可自行查阅资料研究。\n3、双方功能开发完成进行前后端联调。\n")])])]),n("h3",{attrs:{id:"_4-saas平台是如何实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-saas平台是如何实现"}},[a._v("#")]),a._v(" 4 SaaS平台是如何实现")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、理解多租户的概念\n当一个使用SaaS模式部署的软件同时有多个企业用户租用时，每一个企业都是独立的租用者，我们通常称他为：租\n户(tenant)；同时有多个租用者，那就是多租户(multi-tenant)。多租户（Multi-tenant)是SaaS最重要的核心概念\n和关键技术。\n\n2、如何实现SaaS？\n本项目使用公司现成的SaaS系统，实现租户管理、用户管理、角色及权限管理和统一认证的功能。\n平台在注册商户时向SaaS系统写入租户信息完成对接 。\n")])])]),n("h4",{attrs:{id:"_4-4-项目中oauth2-0怎么使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-项目中oauth2-0怎么使用"}},[a._v("#")]),a._v(" 4.4 项目中OAuth2.0怎么使用？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、OAuth2.0是什么？\nOAuth（开放授权）是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不\n需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。\n\nOAauth2.0包括以下角色：\n1）客户端\n本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏\n览器端）、微信客户端等。\n2）资源拥有者\n通常为用户，也可以是应用程序，即该资源的拥有者。\n3）授权服务器（也称认证服务器）\n用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌\n（access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。\n4）资源服务器\n存储资源的服务器，本例子为微信存储的用户信息。\n2、OAuth2.0怎么使用？\nOAuth2.0提供了四种授权(获取令牌)方式：\n1）授权码模式：这种模式是四种模式中最安全的一种模式。一般用于Web服务器端应用或第三方的原生App调用\n资源服务的时候。场景：使用微信登录其它网站。\n2）密码模式：适应于第一方的单页面应用以及第一方的原生App，本项目用户认证使用密码模式。\n3）客户端模式：适应于没有用户参与的，完全信任的一方或合作方服务器端程序接入。\n4）简化模式：适用于第三方单页面应用接入OAuth2.0认证服务。\n")])])]),n("h3",{attrs:{id:"_5-1-c扫b的实现流程是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-c扫b的实现流程是什么"}},[a._v("#")]),a._v(" 5.1 C扫B的实现流程是什么？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("C扫B即买方（顾客）扫商户的二维码完成支付的过程。\n1. 用户向商户发起支付请求\n2. 商户店员使用闪聚支付平台请求获取二维码\n3. 平台请求商户平台应用统一下单接口\n4. 商户平台应用调用交易服务生成支付信息\n5. 商户平台应用根据返回的信息生成二维码返回给前端\n6. 商户店员展示二维码给用户\n7. 用户使用微信或支付宝扫描二维码\n8. 交易服务根据请求类型和支付渠道生成支付确认页面返回给前端\n9. 用户输入金额并点击确认支付\n10. 交易服务收到请求后，保存订单信息并向支付渠道代理服务发起支付请求\n11. 支付渠道代理服务生成渠道支付参数，向微信或支付宝发起支付请求\n12. 根据返回的结果发送支付结果查询消息\n13. 第三方支付生成支付凭据返回给用户的支付客户端\n14. 支付渠道代理服务消费支付结果查询消息\n15. 根据消息内容查询订单支付结果，并发送支付结果消息\n16. 交易服务消费支付结果消息\n17. 根据消息内容更新数据库中的订单支付结果\n")])])]),n("h4",{attrs:{id:"_5-2-二维码如何生成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-二维码如何生成"}},[a._v("#")]),a._v(" 5.2 二维码如何生成？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("使用ZXing一个开源项目完成二维码的生成，ZXing是用Java编写的多格式的1D / 2D条码图像处理库，使用ZXing可\n以生成、识别QR Code（二维码）。\n")])])]),n("h4",{attrs:{id:"_5-4-如何获取支付结果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-如何获取支付结果"}},[a._v("#")]),a._v(" 5.4 如何获取支付结果？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("第三方支付系统提供异步通知支付结果和主动查询支付结果两种方式：\n异步通知支付结果：第三方支付系统调用闪聚支付平台通知支付结果。当通知累积一定次数无法到达，第三方支付\n系统将不再通知。\n主动查询支付结果：闪聚支付平台主动调用第三方支付系统查询支付结果。\n本项目采用MQ完成主动查询支付结果实现。\n")])])]),n("h4",{attrs:{id:"_5-5-项目中mq如何使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-项目中mq如何使用"}},[a._v("#")]),a._v(" 5.5 项目中MQ如何使用？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目使用消息队列RocketMQ完成支付渠道代理服务与交易服务之间的通信，并且用到的RocketMQ 的延迟消息，\n\n1、支付渠道代理服务调用第三方支付下单接口。（此时顾客开始输入密码进行支付）\n2、支付渠道代理向消息队列发送一条延迟消息，消费方仍是支付渠道代理服务。\n3、支付渠道代理调用支付宝接口查询支付结果，如果支付成功将支付结果发送至MQ，消费方是交易服务。\n4、交易服务接收到支付结果消息，更新订单状态。\n")])])]),n("h4",{attrs:{id:"_5-6-项目中redis如何使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-项目中redis如何使用"}},[a._v("#")]),a._v(" 5.6 项目中Redis如何使用？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("渠道参数查询频繁，每一次支付都会查询渠道参数，为提供查询性能这里我们将渠道参数缓存到redis中，缓存流\n程如下：\n1、保存渠道参数添加缓存\n保存渠道参数成功，同时将渠道参数保存在Redis中。\n2、查询渠道参数缓存\n查询渠道参数，先从Redis查询，如果Redis存在则返回渠道参数，否则从数据库查询同时将查询到的渠道参数存储\n在Redis中。\n")])])]),n("h4",{attrs:{id:"_5-7-分布式事务用到的场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-分布式事务用到的场景"}},[a._v("#")]),a._v(" 5.7 分布式事务用到的场景")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("商户入驻会给多张表插入数据，比如商户表，用户表等，所以要加事务保证要么都添加成功，要么都失败回滚。\n")])])]),n("h4",{attrs:{id:"_5-8-elk搜索"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-elk搜索"}},[a._v("#")]),a._v(" 5.8 elk搜索")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("订单表数据量庞大，用elk检索数据明显会比数据库查询速度快\n\n怎么查？\n")])])]),n("h3",{attrs:{id:"_6-数据库分库分表是如何实现的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-数据库分库分表是如何实现的"}},[a._v("#")]),a._v(" 6 数据库分库分表是如何实现的？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目采用微服务架构，每个微服务使用一个数据库，在系统设计上就已经分库了。\n针对订单数据量大的特点，为提高系统的性能使用Sharding-JDBC对订单表进行分库分表。\n方案如下：\n对交易数据库进行分库，对订单表进行分表。\n分库规则：分片键为商户ID，表达式ds$->{MERCHANT_ID % 2}\n\n分表规则：分片键订单表主键，表达式pay_order_$->{ID % 2}\n")])])]),n("h3",{attrs:{id:"_7-项目用到枚举类型了吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-项目用到枚举类型了吗"}},[a._v("#")]),a._v(" 7 项目用到枚举类型了吗？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目用到了枚举类型，以下地方用到枚举：\n1、支付入口 根据客户端类型判断下一步的走向，客户端类型为枚举类型。\n2、支付状态使用枚举类型，系统对每个第三方支付系统的支付结果统一格式为系统枚举类型。\n3、异常代码\n")])])]),n("h3",{attrs:{id:"_8-项目用的日志技术是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-项目用的日志技术是什么"}},[a._v("#")]),a._v(" 8 项目用的日志技术是什么？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("项目记录日志采用log4j2。\nlog4j2是log4j 1.x 的升级版，通过与logback对比分析，log4j2的性能更好，项目组采用log4j2。\n常见的日志框架有哪些？\nlog4j是apache实现的一个开源日志组件\nlogback同样是由log4j的作者设计完成的，拥有更好的特性，是slf4j的原生实现。\nlog4j2是log4j 1.x和logback的改进版，采用了一些新技术使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了\n一些死锁的bug，而且配置更加简单灵活。\n")])])]),n("h3",{attrs:{id:"_9-一个接口出现bug你是怎么调试的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-一个接口出现bug你是怎么调试的"}},[a._v("#")]),a._v(" 9 一个接口出现Bug你是怎么调试的？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、接口的开发需要前端和服务端共同调试，要仔细阅读测试人员反映的bug信息，判断这个bug是服务端的bug还\n是前端的bug。\n服务接口开发完成会使用postman工具进行测试，测试没有问题再提交到Git或SVN。\n前端通常在 mock环境调试接口，不依赖服务端接口，在前后端集成调试时才需要前端连上服务端集成调试。\n2、找到bug的出错点就可以修改Bug。\n如何找bug的出错点？\n根据异常信息，通常有错误代码行的大概位置，再加断点调试及日志跟踪。\n对于生产环境通常跟踪系统日志，通过日志定位bug，所以在编写代码时关键地方一定要加日志。\n3、修改完成需要前后端再次连调测试，按照测试人员提交的测试流程重新进行测试，测试通过将此bug置为已解\n决。\n")])])]),n("h3",{attrs:{id:"_10系统的异常是怎么处理的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10系统的异常是怎么处理的"}},[a._v("#")]),a._v(" 10系统的异常是怎么处理的？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、在服务层抛出自定义异常类型及不可预知异常类型。\n上图中BusinessException为系统的自定义异常类型，程序中在代码显示抛出该异常，此类异常是程序员可预知\n的。\n另一部分是系统无法预知的异常，如：数据库无法连接，服务器宕机等场景下所抛出的异常，此类异常是程序员无\n法预知的异常。\n2、应用层接收到服务层抛出异常继续向上抛出，应用层自己也可以抛出自定义异常类型及不可预知异常类型。\n3、统一异常处理器捕获到异常进行解析。\n判断如果为自定义异常则直接取出错误代码及错误信息，因为程序员在抛出自定义异常时已将错误代码和异常信息\n指定。\n如果为不可预知的异常则统一定义为99999异常代码。\n4、统一异常处理器将异常信息格式为前端要求的格式响应给前端。\n服务端统一将异常信息封装在下边的Json格式中返回：\n")])])]),n("h4",{attrs:{id:"调用第三方支付接口如果超时了怎么办"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调用第三方支付接口如果超时了怎么办"}},[a._v("#")]),a._v(" 调用第三方支付接口如果超时了怎么办？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("支付宝他那个支付接口的话，他有超时的机制，如果说支付失败的话啊，另外我这边儿我支付完了之后，我这边会发延迟消息，就是在去调支付宝那个支付接口之前会发延迟消息，这个延迟消息会发到我自己的那个支付渠道代理服务上，比如我的一个我们会服务里边儿的服务，发到一个注册代理服务上，注意到代理服务，上面那个消费者收到这个消息，他是延迟消息啊，他会像那个支付宝那个查询的那个支付结果那个接口啊，去发一个请求啊，如果说成功的话，就能够得到一个成功的结果，如果失败的话，得到一个失败的结果啊，如果说成功的话，成功或失败，我会把这个再发一条消息发短信到我的那个交易服务交易服务，就会把这个订单的状态改为这个成功和失败。\n")])])]),n("h4",{attrs:{id:"如果支付宝告诉你订单没有收到怎么办-就是查无此单"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如果支付宝告诉你订单没有收到怎么办-就是查无此单"}},[a._v("#")]),a._v(" 如果支付宝告诉你订单没有收到怎么办，就是查无此单？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("什么情况下会查无此单呢，因为我去调第三方支付的话，我会去向查询发送这个参数啊，首先是支付宝必备的一个参数，另外，我们平台的一个唯一的一个订单号，有一个唯一的订单号，我们查询的这个单子的话是对这唯一的订单号来查询的，这个是必须给支付宝传递这个参数，如果说支付宝接受不了这个参数的话，他这个结果是没有办法成功的，要不成功的话，我查询支付结果，那肯定是失败的，他给我想要的结果就失败了。\n")])])]),n("h4",{attrs:{id:"支付宝怎么知道是你们平台发送的请求呢-怎么认证呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#支付宝怎么知道是你们平台发送的请求呢-怎么认证呢"}},[a._v("#")]),a._v(" 支付宝怎么知道是你们平台发送的请求呢，怎么认证呢？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("就是说，我们支付的话其实我们就相当于一个中间商，那我们那个商家入驻的话，加入之后会进行一个资质申请，资质申请完事儿之后，会配那个商家那个门店二维码啊，然后咱们的二维码之后，我们那个会给配那个支付渠道参数，因为每个商家都会去开通这个第三方的支付这个服务吗？然后，比如说唉，比如说今天那个有一个商家开通了这个，那个支付宝的那个支付的我们平台那个服务，然后它就会在支付宝上面会去看到独属于这个商家的那个支付渠道参数，我们会把这个支付渠道参数配置我们的数据库里边儿，然后每次去请求，比如说比如说一个买家去买这个商家的东西，他去扫的码的时候，他就会把我们的平台就会把这个商家的那个支付渠道的这个参数带到支付宝的那个支付接口，嗯嗯嗯嗯，就是这样子。\n")])])]),n("h4",{attrs:{id:"商家的私钥存储在哪里"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#商家的私钥存储在哪里"}},[a._v("#")]),a._v(" 商家的私钥存储在哪里？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("他那个商家的那个私钥还是要配到平台里面的\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("支付模块就是给商家提供的一种，就是聚合支付的功能，比如说商家线下有门店，然后给商家一个聚合功能的码 就是一种聚合渠道 ，用户买东西可以扫这个码，就是用户使用微信呀支付宝之类的，第三方的去扫，商家入驻需要提供营业执照还有老板或者是法人的身份信息，然后最近听说这个也在升级就是加上视频验证，\n调第三方接口因为我们没有支付牌照 只能去调第三方的 支付渠道， 用的是微信jsapi模式，支付宝的key web渠道 扫码之后通过浏览器，扫码之后反馈给用户的页面是我们提供的一个页面，然后页面也会显示一个表单，关于商家信息，商品信息详情 还有用户选择支付的金额，微信这个jsapi是可以满足这个需求的，\n\n\nnacos gateway seata 远程用的是dubbo 没有用feign \n\nseata 用的at模式 因为并发量不高嘛  两阶段提交 ，里面有三个角色嘛tc tm rm 两阶段提交 ，第一个阶段主要就是 里面有那个表 全局锁表 还有分支事务表回去把那个 下单啊 库存啊 分布式事务的场景 根据sql语句 分析记录 执行之前的状态 和执行之后的状态 会存入到seata自带的那个表里面 第二阶段就是 全局提交 还有回滚 提交就是 由事务协调器去进行分支事务的提交 然后回滚就是把数据恢复到 第一阶段保存到数据库的旧镜像的数据 总体就是说 那三个角色互相配合吧 分工合作\n\nribbitmq 就是我们在支付上 用户去扫商家的码去进行支付 ，支付完了 之后 我们有两种查询支付结果的方式  一种 支付宝回调我们平台的接口 另一种就是我们这个消息队列 发布一个延迟消息 因为就是用户扫码之后就是要输入密码啥的 然后不会立刻收到响应 所以我们在调支付接口的同时 会发一个延迟消息 去查这个用户的支付结果 然后把支付结果呢 就是他是发了两个消息一个是支付渠道的那个服务支付渠道的代理服务去发一个消息 发一个延迟消息 然后消费者也是他本身 他自身收到这个延迟消息 就会发一个消息去查支付宝的那个查询结果，然后得到结果后就会再发一个消息 这个服务就会发到我们那个交易服务里 交易服务就会把我们平台维护的那个订单的那个状态给改了 那个订单的状态是由已下单未支付 支付中 支付完成 这些状态 通过发两个消息实现这个场景中mq的运用 ，也是我负责模块mq的运用一个场景\n\n考虑到这个ribbitmq的性能 他是纳秒级 还是毫秒级别的 性能比较好一点 \n这边使用rocketmq也是很合适的 都是有那个延迟队列\nribbtimq 一种是死信队列的  一种是插件的 插件对mq的版本有要求\n    \n第一种 没有消费者  2 队列设置长度 比如说20的长度 超过这个长度就会发到死信队列了\n死信队列的开启就是配交换机 进入死信队列\n\n因为不确定用户多长时间会支付成功 他可能会犹豫 所以延迟消息 延迟多长时间不知道 \nrocketmq 是有一个重复发送的场景 更加合适一点 ribbimq 会更加安全一点 消息更可靠 日志用卡夫卡 rocketmq 不需要数据准确性的 \n我这边ridis的使用场景 用户扫码支付 那个钱是要到商家的账户里面的  要是到商家账户他肯定是要在平台进行支付参数的配置的第三方的那个参数 然后 每次扫码的时候都去找这个接口去调用这个第三方支付参数，如果把他放在数据库中 就是每次都要查数据库 就是对数据库的压力太大 也是性能方面会受到影响  就是会把这个支付参数 放在radis里面 这样调用起来比较快 也让数据库没那么大的访问\n")])])]),n("h2",{attrs:{id:"开放性问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开放性问题"}},[a._v("#")]),a._v(" 开放性问题")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.你为什么离职？\n\n合同到期，之前那家公司朋友推荐的，现在想出来自己发展，趁年轻，多闯闯。\n\n2.你对未来的规划？\n现在首先就是找到一个不错的公司稳定下来，平时做好本职工作，在完成工作的前提下，再去提升自己，提升自己的工作效率，提升客户的满意度。\n\n3.你觉得你的缺点是什么？\n我觉得我最大的缺点就是说话太直，有什么说什么，有什么问题、想法都会当面说出来，所以一旦和别人有矛盾都会当天解决，这同时也算是我的优点吧。\n\n4.你对公司的商业价值是什么？\n我可以给项目提出新的想法，勤奋工作，按时按量完成任务。\n\n5.你对加班的看法？\n如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n接受加班，我平常会提高我的工作效率，避免不必要的加班，如果是项目忙，比较赶项目的时候，我愿意主动的加班。\n\n6.你觉得你最大的成就是什么?\n每当项目交付的时候，成就感是最强的，因为每个产品都像是自己的创造的，看到项目圆满交付。\n")])])]),n("h2",{attrs:{id:"面试真题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面试真题"}},[a._v("#")]),a._v(" 面试真题")]),a._v(" "),n("p",[a._v("#{}和${}的区别")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("#{}是预编译处理，${}是字符串替换。\nMybatis 在处理#{}时，会将sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋\n值；\nMybatis 在处理${}时，就是把${}替换成变量的值。所以可以拼接 SQL 关键字\n使用#{}可以有效的防止 SQL 注入，提高系统安全性\n")])])]),n("p",[a._v("@Autowired和@Resource区别")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("@Autowire 默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为 null，可以设置\n它required属性为false，如果我们想使用按照名称装配，可以结合@Qualifier注解一起使用;\n\n@Resource 默认按照名称装配，当找不到与名称匹配的 bean 才会按照类型装配，可以通过 name\n属性指定，如果没有指定 name 属性，当注解标注在字段上，即默认取字段的名称作为 bean 名称\n寻找依赖对象，当注解标注在属性的 setter 方法上，即默认取属性名作为 bean 名称寻找依赖对\n象\n")])])]),n("p",[a._v("==和equals的区别")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("== 的作用：\n基本类型：比较的就是值是否相同\n引用类型：比较的就是地址值是否相同\n\nequals 的作用:\n引用类型：默认情况下，比较的是地址值。 \n特：String、Integer、Date 这些类库中 equals 被重写，比较的是内容而不是地址！\n\n")])])]),n("p",[a._v("aop常见的通知类型")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Spring 的通知类型有四种，分别为：\n前置通知[]before]：在切点运行之前执行\n后置通知[after-returning]：在切点正常结束之后执行\n异常通知[after-throwing]：在切点发生异常的时候执行\n最终通知[after]：在切点的最终执行\nSpring 还有一种特殊的通知,叫做环绕通知\n环绕通知运行程序员以编码的方式自己定义通知的位置, 用于解决其他通知时序\n问题\n")])])]),n("p",[a._v("AOP底层原理？两种动态代理和对应的特征")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("面向切面编程，利用AOP 可以对业务逻辑的各个部分进行隔离 从而使业务逻辑的各部分之间 耦合度降低，提高程序的可重用性，提高了开发效率，通俗的讲  可以实现不修改源代码的方式，在核心业务里面 添加新的功能\n实现AOP的技术主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态植入的方式（静态代理），引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码\n\n动态代理有两种实现方式\nJDK动态代理实现（基于接口）      代理对象和真实对象的关系  像是兄弟   代理对象 对真实对象进行增强\nCGlib动态代理实现（基于继承）    代理对象和真实对象的关系  就像是 父子\n")])])]),n("p",[a._v("arraylist初始容量，怎么扩容的\narraylist和linkedlist的区别\nArrayList和LinkList区别和使用场景\narraylist扩容时为什么要复制数组")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("（1）ArrayList 是一种变长的集合类，基于定长数组实现，使用默认构造方法初始化出来的容\n量是 10（1.7 之后都是延迟初始化，即第一次调用 add 方法添加元素的时候才将 elementData\n容量初始化为 10）。\n（2）ArrayList 允许空值和重复元素，当往 ArrayList 中添加的元素数量大于其底层数组容量\n时，其会通过扩容机制重新生成一个更大的数组。ArrayList 扩容的长度是原长度的 1.5 倍，然\n后将旧数组内容复制到新创建的更大的数组中。\n（3）由于 ArrayList 底层基 于数组实现，所以其可以保证在 O(1) 复杂度下完成随机查找操作。\n（4）ArrayList 是非线程安全类，并发环境下，多个线程同时操作 ArrayList，会引发不可预\n知的异常或错误。\n（5）顺序添加很方便\n（6）删除和插入需要复制数组，性能差（可以使用 LinkindList）\n（7）Integer.MAX_VALUE - 8 ：主要是考虑到不同的 JVM,有的 JVM 会在加入一些数据头,当扩\n容后的容量大于 MAX_ARRAY_SIZE,我们会去比较最小需要容量和 MAX_ARRAY_SIZE 做比较,如果比\n它大, 只能取 Integer.MAX_VALUE,否则是 Integer.MAX_VALUE -8。 这个是从 jdk1.7 开始才有\n的\n\n\nArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加\n和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，\n所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能\n上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后\n向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\n")])])]),n("p",[a._v("ConcurrentHashMap的底层原理是什么？为什么是线程安全的")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("ConcurrentHashMap 是\nJDK1.7 使用了锁分段技术来保证线程安全的。JDK1.8ConcurrentHashMap 取消了\nSegment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8\n的结构类似，数组+链表/红黑二叉树。\nsynchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就\n不会产生并发，效率又提升 N 倍。\n")])])]),n("p",[a._v("controller和restcontroller有什么区别")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("@RestController 是 @Controller 和 @ResponseBody 的 结 合 , 一 个 类 被 加 上\n@RestController 注解,数据接口中就不再需要添加@ResponseBody,更加简洁。\n\n@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用。\n1) 如果只是使用@RestController 注解 Controller，则 Controller 中的方法无法返回 jsp 页面，\n或者 html，配置的视图解析器 InternalResourceViewResolver 不起作用，返回的内容就是\nReturn 里的内容。\n2) 如果需要返回到指定页面，则需要用 @Controller 配合视图解析器\nInternalResourceViewResolver 才行。\n如果需要返回 JSON，XML 或自定义 mediaType 内容到页面，则需要在对应的方法上加上\n@ResponseBody 注解。\n")])])]),n("p",[a._v("cpu的调度算法")]),a._v(" "),n("p",[a._v("Dubbo的负载均衡和熔断策略有哪些")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Random LoadBalance:随机，按权重设置随机概率(默认)\nRoundRobin LoadBalance：轮询，按公约后的权重设置轮询比率\nLeastActive LoadBalance：最少活跃调用次数，相同活跃数的随机\nConsistentHash LoadBalance：一致性 Hash，相同参数的请求总是发到同一提供者\n")])])]),n("p",[a._v("dubbo在你项目中起了什么作用\nfeign和Dubbo的区别，Dubbo好在哪些方面\nfinal关键字作用")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("被 final 修饰的类不可以被继承，被 final 修饰的方法不可以被重写，被 final 修饰的变量不可\n以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.被 final 修饰的方法,JVM\n会尝试将其内联,以提高运行效率，被 final 修饰的常量,在编译阶段会存入常量池中.\n")])])]),n("p",[a._v("GC Root从那些地方开始")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.虚拟机栈（栈帧中的本地变量表）中引用的对象；\n\n2.方法区中的类静态属性引用的对象；\n\n3.方法区中常量引用的对象；\n\n4.本地方法栈中JNI（即一般说的Native方法）中引用的对象\n")])])]),n("p",[a._v("GC在堆中执行流程")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.初始标记(Initial Marking)：这阶段仅仅只是标记GC Roots能直接关联到的对象并修改TAMS(Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要停顿线程，但是耗时很短。而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。\t\n\n2.并发标记(Concurrent Marking)：从GC roots使用可达式算法，对堆内存中对象进行标记（三色标记法），递归扫描整个堆。该步骤耗时过长，是与用户业务程序并发执行。\n\n3.最终标记(Final Marking)：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来 的最后那少量的 SATB 记录。\n\n4.筛选回收(Live Data Counting and Evacuation)：负责更新 Region 的统计数据，对各个 Region 的 回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。可以自由选择多个Region 来构成会收集，然后把回收的那一部分Region中的存活对象==复制==到空的Region中，在对那些 Region进行清空。\n")])])]),n("p",[a._v("HashMap jdk1.7和1.8增加了哪些特性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1 Lambda 表达式\nLambda 允许把函数作为一个方法的参数。\n\n2 方法引用\n方法引用允许直接引用已有 Java 类或对象的方法或构造方法\n\n3 函数式接口\n有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为\nLambda 表达式。通常函数式接口上会添加@FunctionalInterface 注解\n\n4 接口允许定义默认方法和静态方法\n从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法\n\n5 Stream API\n新添加的 Stream API（java.util.stream）把真正的函数式编程风格引入到 Java\n中。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，\n排序，聚合等。\n\n6 日期/时间类改进\n之前的 JDK 自带的日期处理类非常不方便，我们处理的时候经常是使用的第三方\n工具包，比如 commons-lang\n包等。不过 JDK8 出现之后这个改观了很多，比如日期时间的创建、比较、调整、\n格式化、时间间隔等。\n这些类都在 java.time 包下，LocalDate/LocalTime/LocalDateTime\n")])])]),n("p",[a._v("hashmap产生冲突怎么解决\nHashMap底层实现原理\nHashSet的底层原理是什么\nHashSet与HashMap的区别")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。\n在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。\n因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回\nfalse\n如何来保证元素唯一性?\n依赖两个方法：hashCode()和 equals()\n")])])]),n("p",[a._v("http的执行流程（三次握手）")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("第一次握手：客户端给服务器发送一个 SYN。客户端发送网络包，服务端收到了。服\n务器得出结论：客户端的发送能力，服务端的接收能力正常。\n第二次握手：服务端收到 SYN 报文之后，会应答一个 SYN+ACK 报文。服务端发包，客户\n端收到了。客户端得出结论：服务端的接收和发送能力，客户端的接收和发送能力正常。但\n是此时服务端不能确认客户端的接收能力是否正常。\n第三次握手;客户端收到 SYN+ACK 报文之后，回应一个 ACK 报文。客户端发包，服务端收\n到了。服务器得出结论：客户端的接收和发送能力，自己的接收发送能力都正常。\n通过三次握手，双方都确认对方的接收以及发送能力正常\n")])])]),n("p",[a._v("innodb和myisam的底层数据结构")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("InnoDB引擎：支持事务，支持行级锁和表级锁默认为行级锁，支持外键，不支持全文检索，InnoDB是为处理巨大数据量时的最大性能设计，它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的，且底层B+树结构中的键和数据有序地存放在一起。\nMyIsam引擎：不支持事务、外键，只支持表级锁，支持全文索引，MyISAM引擎的表在大量高并发的读写下会经常出现表损坏的情况，对于count()查询来说MyISAM更有优势，MyISAM引擎的表的查询、更新、插入的效率要比InnoDB高，底层B+树结构中键对应的是数据对应的磁盘地址。\n")])])]),n("p",[a._v("IOC原理")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("控制反转 对象的创建和维护交给ioc容器来实现，不再由程序员自己创建，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 IOC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。使用 IOC 目的：为了耦合度降低，底层原理是 xml 解析、工厂模式、反射。\n")])])]),n("p",[a._v("BIO、NIO、AIO 有什么区别？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简\n单使用方便，并发处理能力低。\nNIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过\nChannel（通道）通讯，实现了多路复用。\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，\n异步 IO 的操作基于事件和回调机制。\n")])])]),n("p",[a._v("Java的动态代理的用法是什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("(1)JDK 动态代理只提供接口代理，不支持类代理，核心 InvocationHandler 接口和\nProxy 类，InvocationHandler 通过 invoke()方法反射来调用目标类中的代码，动态地将\n横切逻辑和业务编织在一起，Proxy 利用 InvocationHandler 动态创建一个符合某一接口\n的的实例, 生成目标类的代理对象\n\n(2) 如果代理类没有实现 InvocationHandler 接口，那么 Spring AOP 会选择使用\nCGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，\n可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从\n而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，\n那么它是无法使用 CGLIB 做动态代理的\n")])])]),n("p",[a._v("JDK8里面有哪几种类加载器")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("启动类加载器：Bootstrap ClassLoader，负责加载存放在 JDK\\jre\\lib(JDK 代表 JDK 的安装目\n录，下同)下，或被-Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库\n\n扩展类加载器：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，\n它负责加载 DK\\jre\\lib\\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库\n（如 javax.*开头的类），开发者可以直接使用扩展类加载器。\n\n应用程序类加载器：Application ClassLoader，该类加载器由\nsun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，\n开发者可以直接使用该类加载器\n\n")])])]),n("p",[a._v("jvm程序计数器有什么用")]),a._v(" "),n("p",[a._v("JVM的元空间用来干什么，用元空间有什么好处")]),a._v(" "),n("p",[a._v("jvm的运行数据区域有哪些")]),a._v(" "),n("p",[a._v("jvm内存模型 那些是私有的")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("JVM的内存主要包括程序计数器，java虚拟机栈，本地方法栈，Java堆区，方法区\n\n（线程私有）\n程序计数器：一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器，如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。\n\njava虚拟机栈：Java虚拟机栈也是线程私有的。虚拟机栈描述的是Java方法执行的内存模型；每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n本地方法栈：本地方法栈与虚拟机栈所发挥的作用是非常相似的，而本地方法栈是为虚拟机使用到的Native方法服务。\n\n（线程共享）\nJava堆：Java堆是Java虚拟机所管理的内存中最大的一块，可以分为新生代和老年代，老年代和新生代占的内存比例是2：1，新生代又分为Eden和S0和S1区，他们的比例是8：1：1。\n\n方法区：方法区是JVM规范中定义的一个概念，与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量、静态变量等信息，在jdk1.7之前叫永久代，1.8之后叫元数据区\n")])])]),n("p",[a._v("kafaka了解吗\nlinux查看cpu的使用率")]),a._v(" "),n("p",[a._v("Linux的常用命令，如（删除文件rm，后面的参数）")]),a._v(" "),n("p",[a._v("linux中管道命令和查端口号被占用问题")]),a._v(" "),n("p",[a._v("mybatis的数据传输形式")]),a._v(" "),n("p",[a._v("mybatis的一级缓存和二级缓存")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Mybatis 有两级缓存，一级缓存是 SqlSession 级别的，默认开启，无法关闭；二级缓\n存是 Mapper 级别的，二级缓存默认是没有开启的，但是手动开启\n")])])]),n("p",[a._v("mybatis怎么实现批量插入，使用的是哪条语句（方法）")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("insert into table [(列名),(列名)] values [(列值),(列值)]\n")])])]),n("p",[a._v("Mybatis中动态SQL使用了哪些标签元素")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1. <if>if 是为了判断传入的值是否符合某种规则,比如是否不为空.\n\n2. <where> where 标签可以用来做动态拼接查询条件,当和 if 标签配合的时候,不\n用显示的声明类型 where 1 = 1 这种无用的条件\n\n3. <foreach> foreach 标签可以把传入的集合对象进行遍历,然后把每一项的内容\n作为参数传到 sql 语句中. \n4. <include> include 可以把大量的重复代码整理起来,当使用的时候直接 include\n即可,减少重复代码的编写;\n\n5. <set>适用于更新中,当匹配某个条件后,才会对该字段进行跟新操作\n")])])]),n("p",[a._v("mysql的事务的隔离级别,默认是什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("\n读取未提交（Read Uncommitted）\n\n读取已提交（Read Committed）\n\n可重复读（Repeatable Read）\t默认\n\n序列化读（Serializable）\n")])])]),n("p",[a._v("mysql存储引擎myisma和innoDB\nMysql的默认事务隔离级别，它的作用是什么\nMySQL的最佳左前缀索引是什么")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。\n\n在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。\n\n就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。\n\n可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。\n\n")])])]),n("p",[a._v("MySQL如何实现幂等性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("幂等性：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。\n\n基于 redis 实现\n这种实现方式是基于 SETNX 命令实现的\n\n使用状态机、悲观锁、乐观锁的方式来实现\n")])])]),n("p",[a._v("nacos的具体作用")]),a._v(" "),n("p",[a._v("nacos原理")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部\n署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手\n动更改属性可能会产生问题。\nNacos 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Nacos 服务器上注册并通过调用 Nacos 服务器完成查找，因此无需处理服务地点的任何更改和处理\n")])])]),n("p",[a._v("OAuth2的单点登录\nOAuth2的四种授权模式")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("授权码模式（authorization code）\n简化模式（implicit）\n密码模式（resource owner password credentials）\n客户端模式（client credentials）\n")])])]),n("p",[a._v("ORM使用的……？\nrabbitMQ消息丢失问题")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("第一种：生产者没能成功将消息发送到 MQ;\nb、 解决办法： 有两个解决办法：事务机制和 confirm 机制，最常用的是 confirm\n\n第二种：MQ 在接收到消息后弄丢了消息\nb、 解决办法：开启 RabbitMQ 的持久化。当生产者把消息成功写入 RabbitMQ 之后，RabbitMQ\n就把消息持久化到磁盘\n\n第三种：消费者弄丢了消息\n：简单来说，就是必须关闭 RabbitMQ 的自动 `ack`，\n")])])]),n("p",[a._v("redission的分布式锁")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key 为val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。为锁添加一个超时时间，通过redission中的“看门狗”模式，就是当线程执行时，会去查看进程有没有执行完，如果没有执行完，会给进程延长锁的存在时间，看门狗模式中，有一个默认时间30s，然后看门狗会在lockwatchdogTimeout/3,也就是每10s查看一次当前进程有没有执行完，没有执行完，把时间在延长至30秒。\n2.获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。\n还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n3.释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n")])])]),n("p",[a._v("Zookeeper的分布式锁")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("每个客户端对某个方法加锁时，在zookeeper上该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。，判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个，当释放锁的时候，只需将这个瞬时节点删除即可。zookeeper这种方式可以避免服务宕机而产生的所无法释放形成的死锁问题。\n")])])]),n("p",[a._v("redis的持久化策略，答出来叫你具体分析一下那两个的区别，")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Redis的持久化方式分为两种：aof和rdb。\naof:采用的是记录日志的方式，较为安全，最大丢失数据不超过两秒，文件存储的是命令的形式，可简单的读懂，但恢复速度慢，容易造成阻塞问题。\nrdb:采用的是快照的方式，效率高，是一个压缩的二进制文件，文件占用空间少，但容易丢失数据，发生异常时，最后一次快照会丢失掉，恢复数据得到速度快，数据过大时，fork操作占用过多的系统资源，容易造成主服务器进程假死。\n\n如果两个都配了优先加载 AOF\n")])])]),n("p",[a._v("redis的穿透，击穿什么情况 以及他们的解决方案")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("缓存击穿：就是某一个热点数据，缓存中某一时刻失效了，因而大量并发请求打到数据库上，就像被击穿了一样。\n解决方案：1）通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线程\n         2）设置value永不过期\n         3）使用互斥锁(mutex key)\n         \n缓存穿透：出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: key在缓存并且数据库中不存在，所以每次查          询都会查询数据库从而导致数据库崩溃。\n解决方案：1） 使用布隆过滤器: 热点数据等场景(具体看使用场景)\n\n缓存雪崩：雪崩指的是多个key查询并且出现高并发，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然          升，从而崩溃。\n解决方案：1）可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存\n         2）不同的key，设置不同的过期时间，具体值可以根据业务决定，让缓存失效的时间点尽量均匀\n         3）做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时          间设置为短期，A2设置为长期。\n缓存倾斜：又称热点key倾斜，就是一个热点key存在一个redis集群上，结果被访问时，高并发的集中到一台服务器上          ，从而造成倾斜。\n解决方案：1）将一些特别热点的key直接放在客户端进行存储，设置过期时间，过期后再从后台中查询\n")])])]),n("p",[a._v("redis的底层")]),a._v(" "),n("p",[a._v("redis和数据库的数据一致性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.数据库单机的情况\n先更新数据库，再删除缓存\n设置缓存过期时间+延时双删\n延时双删进行保障：在请求B更新完数据库值以后，让它先sleep一小段时间，确保请\n求A能够先从数据库读取数据，再把缺失的数据写入缓存，然后，请求B再进行删除。后续其它线程读取\n数据时，发现缓存缺失，会从数据库中读取最新值。\n\n2.mysql读写分离（主从架构模式）\n通过阿里巴巴canal和RabbitMq来订阅binlog，实现异步删除\n通过数据库的binlog（二进制日志binnary log 以事件形式记录了对MySQL数据库执行更改的所有操作。）来异步淘汰key，利用工具(canal)将binlog日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存。\n")])])]),n("p",[a._v("redis集群的几种模式 持久化方式 项目中用了那种方式")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.主从复制；2.Sentinel哨兵机制；3.cluster集群。\n")])])]),n("p",[a._v("如何保证接口的幂等性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1、前端拦截\n\n前端拦截是指通过 Web 站点的页面进行请求拦截，比如在用户点击完“提交”按钮后，我们可以把按钮设置为不可用或者隐藏状态，避免用户重复点击。\n\n但前端拦截有一个致命的问题，如果是懂行的程序员或者黑客可以直接绕过页面的 JS 执行，直接模拟请求后端的接口，这样的话，我们前端的这些拦截就不能生效了。因此除了前端拦截一部分正常的误操作之外，后端的验证必不可少。\n\n2、使用数据库实现幂等性\n\n\ta、通过悲观锁来实现幂等性\n\n\tb、通过唯一索引来实现幂等性\n\n\tc、通过乐观锁来实现幂等性\n3、使用 JVM 锁实现幂等性\n\nJVM 锁实现是指通过 JVM 提供的内置锁如 Lock 或者是 synchronized 来实现幂等性。使用 JVM 锁来实现幂等性的一般流程为：首先通过 Lock 对代码段进行加锁操作，然后再判断此订单是否已经被处理过，如果未处理则开启事务执行订单处理，处理完成之后提交事务并释放锁\n\n4、使用分布式锁实现幂等性\n\n分布式锁实现幂等性的逻辑是，在每次执行方法之前先判断是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可\n")])])]),n("p",[a._v("如何保证MQ消息队列的幂等性")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("1.插入时查询一次\n在每次插入数据的时候，查询表中该数据是否存在，如果存在我们就不用插入了，在并发不高的时候我们可以使用这个方法\n\n2.添加唯一约束\n如果数据库没有分库分表，我们可以在可能会发生重复的字段上添加唯一约束（UNIQUE），这样就不会出现重复的记录了\n\n3.使用Redis\n如果数据库是分布式的，并且做了分库分表，那么我们可以使用Redis来记录，把每个消费的消息的id存入Redis，这样重复消费的时候，Redis中已经有了就不能消费                     \n\n4.使用锁\n如果系统处在高并发下，我们可以使用 Redis或者zookeeper的分布式对消息 id加锁，然后使用上面几种方法来控制幂等性\n")])])]),n("p",[a._v("Redis有哪些数据类型")]),a._v(" "),n("p",[a._v("redis为什么是单线程的还那么多人用")]),a._v(" "),n("p",[a._v("Redis在项目中的使用场景")]),a._v(" "),n("p",[a._v("@ResponseBody注解的作用")]),a._v(" "),n("p",[a._v("ResultMap标签的作用,为什么要通过它来映射,直接查询时不用映射也可以,为什么还要用resultMap\nsofaboot\nspringapplication类是什么用途？\nSpringBean的生命周期,说7条面试官说不全面\nSpringboot1和SpringBoot2的区别\nSpringBoot常用注解\nspringboot的主要安全组件是哪个？\nspringboot的注入过程\nspringboot是支持松绑定的，松绑定这个概念有了解吗？\nSpringcloud的原生组件有哪些？\nspringcloud跟dubbo有什么区别？\nspringcloud几大组件？\nspringcloud是如何实现服务注册和发现的？\nSpringMvc的执行流程\nSpring解析@ComponentScan注解的执行流程\nSpring中autowired注入自己的代理后，最后容器中的对象是原对象还是代理对象\nSQL的优化有了解吗\nString类型常用的操作字符串的方法\nUML建模\nvi与vim的区别\n比如资质申请的时候怎么去审核\n避免重复消费解决方案: 幂等性。\n遍历数组的时候能不能增删\n查询根据一个条件在两张表中查询数据\n程序计数器的干什么用的\n除了常用的单例模式和代理模式、工厂模式，还了解那些\n存图片地址会存哪些 这个地址是怎么获取的\n当突然收到大量的请求怎么去处理\n当我们去访问www.baidu.com的时候，有哪些过程\n动态sql\n堆中GC的划分 对应区域使用的算法\n对aop的理解，原理是什么，他自带的jdk原生动态代理是怎么具体实现的\n对springboot你能大概讲一下吗？有什么优缺点？然后它的主要用途是什么？\n对spring的理解\n对项目做一个介绍\n多线程的实现方式\n二分查找法是怎么查的\n分库分表\n服务怎么向nacos注册\n跟产品的关系怎么样？\n工作了几年，对薪资的期望（过一面了）\n工作上有哪些有成就感，又有哪些不能接受的地方？\n关于设计模式有哪些了解\n假如存入的是一个product实体类对象，使用redis怎样存储。\n简单介绍下OAuth2\n讲一下Hashmap与TreeMap的区别\n开发时业务层常用的注解\n了不了解索引\n类加载的过程\n类加载过程中静态变量所在存储空间\n类加载器有哪些\n两个int类型的封装类integer 他俩的值比较相等不相等用==还是equals\n两个线程对数据库中的数据进行修改，数据被修改过一次后，不能再被修改，怎么实现（通过数据库的方式）\n聊聊两种代理模式的区别\n聊一下mq消息的丢失，积压\n聊一下单例（饿汉懒汉）\n聊一下什么jms\n描述一下b+tree长啥样\n秒杀中，只允许接收一部分请求，怎样实现\n那个list实现是安全的\n那几种负载均衡，负载均衡算法\n那你服务之间调用的框架是什么\n你对 spring AOP 和 IOC的 理解\n你项目中用到的是什么消息队列\n平时开发时调用其他服务某个接口是怎么调用的 使用了哪些注解\n七牛云图片上传七牛云的接口是怎么调取的\n前端用的是什么技术\n请求经过网关和Dubbo的流程\n日常工作中你用过哪些关于安全方面的组件？\n熔断降级怎么判断超时，需要被熔断或降级\n如果想用线程安全的Map该怎么办\n如果用Redis实现分布式锁有哪几种方案\n什么是幂等性\n什么是双亲委派\n使用pageHelper会出现哪些问题\n使用Redis的持久化时，存储数据量较大时，是否会影响外部线程的请求\n事务传播级别行为7种\n事务的隔离级别？怎么实现可重复读\n事务的隔离级别都是哪些，分别介绍脏读、不可重复读、幻读\n首先问了项目中的一些实现，问项目比较细\n数据库的事务特性（原子，一致、、、）\n数据库都有什么索引\n数据库分片\n数据库数据和redis缓存数据如何保持一致\n双亲委派机制\n说一下hash碰撞\n说一下工厂模式\n说一下红黑树（我如果在红黑树上找一个数据，该怎么找）\n说一下你用的最多的collection的子接口\n索引都有哪些，覆盖索引与回表\n索引一般用在什么字段上\n图片上传到七牛云之后本地数据库会不会储存一些信息 对图片信息进行一些记录\n微服务中sentinel为什么可以熔断降级，原理是什么。\n为什么不用dubbo的rpc\n为什么用二级缓存\n我这方面没什么要问的了，你还有什么要问的吗\n细分文档（时序图)\n先做个自我介绍\n线程安全的集合都有哪些。\n线程池的参数\n线程池的执行流程\n消息重复消费问题\n一般索引用在哪些字段上\n用户线程与守护线程有什么区别\n用技术描述一下你的金融项目，不听你说业务\n有没有用过分布式系统相关的组件\n有用过dubbo吗\n于你个人而言，你觉得软件开发这个行业是怎样一个行业？\n元空间都有什么 存什么数据的\n远程服务调用怎么调用的\n在springboot中读取配置文件的方式有哪些\n在多线程里面cas操作是什么\n在使用springboot的时候，javaconfig跟之前的xml配置之间有什么区别？他是类型安全的吗？\n在使用事务的传播行为时，service层里的方法上没有注解，但是在其他service层中定义此service中的方法，并带有注解，是否有效\n在项目中使用到多线程的场景\n在做外包的时候，最主要关注的点在哪里？\n怎么保证消息不被重复消费\n怎么处理大容量并发问题\n怎么创建线程池\n怎么去回调平台传给我们的信息\n怎么在5亿条数据中查询到自己的信息\n自动装配的原理\n自己写的代码中有写过关于设计模式的代码吗？不问设计模式原理和spring底层涉及到的设计模式，只问亲手写过没涉及到设计模式的代码。\n字符串替换用的方法\n阻塞io和非阻塞io")])])}),[],!1,null,null,null);n.default=t.exports}}]);