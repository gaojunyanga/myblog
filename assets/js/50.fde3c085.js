(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{468:function(n,e,t){"use strict";t.r(e);var a=t(2),O=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("1.PO(persisitant object) 持久层对象\nPO 就是对应数据库中某个表的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("2.DO（Domain Object） 领队对象\nDO就是从现实世界中抽象出来的有形或无形的业务实体。")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("3.TO(Transfer Object) ，数据传输对象\n不同的应用程序之间传输的对象")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("4.DTO（Data Transfer Object）数据传输对象\n这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的\n数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这\n里，泛指用于展示层与服务层之间的数据传输对象。")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("5.VO(value object) 值对象\n通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出\n的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由\nGC 回收的。\nView object：视图对象；\n接受页面传递来的数据，封装对象\n将业务处理完成的对象，封装成页面要用的数据")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("6.BO(business object) 业务对象\n从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对\n象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。business object: 业务对象 主要作\n用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简\n历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经\n历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每\n个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("7.POJO(plain ordinary java object) 简单无规则 java 对象\n传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护\n数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增\n加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter\n方法！。\nPOJO")]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("8.DAO(data access object) 数据访问对象\n是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久\n层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包\n含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业\n务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作")])])}),[],!1,null,null,null);e.default=O.exports}}]);