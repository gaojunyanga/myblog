<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>glls</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="纸上得来终觉浅 觉知此事需躬行">
    
    <link rel="preload" href="/assets/css/0.styles.cdbb3724.css" as="style"><link rel="preload" href="/assets/js/app.cf24e5c2.js" as="script"><link rel="preload" href="/assets/js/3.96e6e8dc.js" as="script"><link rel="preload" href="/assets/js/1.9cd0fbb8.js" as="script"><link rel="preload" href="/assets/js/24.93bb133f.js" as="script"><link rel="prefetch" href="/assets/js/10.e6679e1d.js"><link rel="prefetch" href="/assets/js/11.9031e886.js"><link rel="prefetch" href="/assets/js/12.7027c54a.js"><link rel="prefetch" href="/assets/js/13.000bd0c6.js"><link rel="prefetch" href="/assets/js/14.ed887876.js"><link rel="prefetch" href="/assets/js/15.a00f8181.js"><link rel="prefetch" href="/assets/js/16.6194edbb.js"><link rel="prefetch" href="/assets/js/17.35574e05.js"><link rel="prefetch" href="/assets/js/18.b4a0dc23.js"><link rel="prefetch" href="/assets/js/19.bbfbdcdb.js"><link rel="prefetch" href="/assets/js/20.f9712cb5.js"><link rel="prefetch" href="/assets/js/21.c5d37f51.js"><link rel="prefetch" href="/assets/js/22.8b74c1d6.js"><link rel="prefetch" href="/assets/js/23.afb7d1dd.js"><link rel="prefetch" href="/assets/js/25.174e73e9.js"><link rel="prefetch" href="/assets/js/26.1f08cfe8.js"><link rel="prefetch" href="/assets/js/27.f5387759.js"><link rel="prefetch" href="/assets/js/28.464ce114.js"><link rel="prefetch" href="/assets/js/29.62eca51f.js"><link rel="prefetch" href="/assets/js/30.eeb93e3b.js"><link rel="prefetch" href="/assets/js/31.119e5f3b.js"><link rel="prefetch" href="/assets/js/32.375b3a8c.js"><link rel="prefetch" href="/assets/js/33.2a684361.js"><link rel="prefetch" href="/assets/js/34.4bd3bd53.js"><link rel="prefetch" href="/assets/js/35.fc2b775b.js"><link rel="prefetch" href="/assets/js/36.3cf77c8a.js"><link rel="prefetch" href="/assets/js/37.f2330e4e.js"><link rel="prefetch" href="/assets/js/38.537589f8.js"><link rel="prefetch" href="/assets/js/39.d6b70184.js"><link rel="prefetch" href="/assets/js/4.49793d4e.js"><link rel="prefetch" href="/assets/js/40.59f90851.js"><link rel="prefetch" href="/assets/js/41.a239b386.js"><link rel="prefetch" href="/assets/js/42.1e9cf7f1.js"><link rel="prefetch" href="/assets/js/43.917a5a3e.js"><link rel="prefetch" href="/assets/js/44.d31fbeb1.js"><link rel="prefetch" href="/assets/js/45.0b30863c.js"><link rel="prefetch" href="/assets/js/46.fa698e27.js"><link rel="prefetch" href="/assets/js/47.5cb4f5d8.js"><link rel="prefetch" href="/assets/js/48.8ddd1ecc.js"><link rel="prefetch" href="/assets/js/49.caf008b4.js"><link rel="prefetch" href="/assets/js/5.3e5c9da5.js"><link rel="prefetch" href="/assets/js/50.fde3c085.js"><link rel="prefetch" href="/assets/js/51.db458b1d.js"><link rel="prefetch" href="/assets/js/52.2cd02180.js"><link rel="prefetch" href="/assets/js/53.48a1e4d8.js"><link rel="prefetch" href="/assets/js/54.98d82cfd.js"><link rel="prefetch" href="/assets/js/6.e9258025.js"><link rel="prefetch" href="/assets/js/7.3130d9c3.js"><link rel="prefetch" href="/assets/js/8.eca9b250.js"><link rel="prefetch" href="/assets/js/9.e91cc53b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cdbb3724.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>glls</h3> <p class="description" data-v-59e6cb88>纸上得来终觉浅 觉知此事需躬行</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">glls</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active"><i class="undefined"></i>
  java
</a></div><div class="nav-item"><a href="/front/" class="nav-link"><i class="undefined"></i>
  前端
</a></div><div class="nav-item"><a href="/pro/" class="nav-link"><i class="undefined"></i>
  项目案例
</a></div><div class="nav-item"><a href="/mianshi/" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><a href="/qa/" class="nav-link"><i class="undefined"></i>
  QA
</a></div><div class="nav-item"><a href="/bishe/" class="nav-link"><i class="undefined"></i>
  毕设
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      在线资料
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/712139234359182/posts" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://i.heyige.cn/interview/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  东哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/laorenyuma/bh9tm1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  瑞哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://codingsir.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  邢哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://modao.cc/community?source=nav&amp;page=1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  原型图网站1
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.axureshop.com/a/b/axure-prototypes" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  原型图网站2
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>13</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active"><i class="undefined"></i>
  java
</a></div><div class="nav-item"><a href="/front/" class="nav-link"><i class="undefined"></i>
  前端
</a></div><div class="nav-item"><a href="/pro/" class="nav-link"><i class="undefined"></i>
  项目案例
</a></div><div class="nav-item"><a href="/mianshi/" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><a href="/qa/" class="nav-link"><i class="undefined"></i>
  QA
</a></div><div class="nav-item"><a href="/bishe/" class="nav-link"><i class="undefined"></i>
  毕设
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      在线资料
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/712139234359182/posts" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://i.heyige.cn/interview/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  东哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/laorenyuma/bh9tm1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  瑞哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://codingsir.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  邢哥
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://modao.cc/community?source=nav&amp;page=1" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  原型图网站1
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.axureshop.com/a/b/axure-prototypes" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  原型图网站2
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/java/" class="sidebar-heading clickable router-link-active open"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/java/part1/test1" class="sidebar-heading clickable"><span>part1</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/java/part2/servlet.html" class="sidebar-heading clickable"><span>part2</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/java/part3/mybatis" class="sidebar-heading clickable"><span>part3</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group depth-0"><a href="/java/part4/1linux" class="sidebar-heading clickable"><span>part4</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/part4/1linux.html" class="sidebar-link">1linux</a></li><li><a href="/java/part4/2docker.html" class="sidebar-link">2docker</a></li><li><a href="/java/part4/3nginx.html" class="sidebar-link">3nginx</a></li><li><a href="/java/part4/4redis.html" class="sidebar-link">3redis</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title"></h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="springboot-glls"><a href="#springboot-glls" class="header-anchor">#</a> SpringBoot----glls</h1> <h2 id="_1-springboot是什么"><a href="#_1-springboot是什么" class="header-anchor">#</a> 1.SpringBoot是什么</h2> <p>我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。<strong>繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低</strong>。</p> <p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求<strong>在 Spring 框架中支持无容器 Web 应用程序体系结构</strong>。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：</p> <blockquote><p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 <code>main()</code>方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。</p></blockquote> <p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.2.10 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而<strong>是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具</strong>。</p> <p>它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。</p> <h2 id="_2-为什么学习spring-boot"><a href="#_2-为什么学习spring-boot" class="header-anchor">#</a> 2.为什么学习Spring Boot</h2> <p>易学难精</p> <h3 id="_2-1-从spring官方来看"><a href="#_2-1-从spring官方来看" class="header-anchor">#</a> 2.1 从Spring官方来看</h3> <p>我们打开 Spring 的<a href="http://spring.io/" target="_blank" rel="noopener noreferrer">官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，可以看到下图：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200902152733795.png" alt="image-20200902152733795"></p> <p>我们可以看到图中官方对 Spring Boot 的定位：<em>Build Anything</em>， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：</p> <p>SpringCloud：<em>Coordinate Anything</em>，协调任何事情；
SpringCloud Data Flow：<em>Connect everything</em>，连接任何东西。</p> <p>仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。</p> <h3 id="_2-2-从spring-boot的优点来看"><a href="#_2-2-从spring-boot的优点来看" class="header-anchor">#</a> 2.2 从Spring Boot的优点来看</h3> <p>Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200902152812908.png" alt="image-20200902152812908"></p> <h4 id="_2-2-1-良好的基因"><a href="#_2-2-1-良好的基因" class="header-anchor">#</a> 2.2.1 良好的基因</h4> <p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200902152840432.png" alt="image-20200902152840432"></p> <h4 id="_2-2-2-简化编码"><a href="#_2-2-2-简化编码" class="header-anchor">#</a> 2.2.2 简化编码</h4> <p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的弟弟都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></div><p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- .....省略其他依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre></div><p>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p> <h4 id="_2-2-3-简化配置"><a href="#_2-2-3-简化配置" class="header-anchor">#</a> 2.2.3 简化配置</h4> <p>Spring 虽然是Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p> <p>我新建一个类，但是我不用 <code>@Service</code>注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要<code>@Configuration</code> 和<code>@Bean</code>两个注解即可，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>public class TestService {
    public String sayHello () {
        return &quot;Hello Spring Boot!&quot;;
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JavaConfig {
    @Bean
    public TestService getTestService() {
        return new TestService();
    }
}
</code></pre></div><p><code>@Configuration</code>表示该类是个配置类，<code>@Bean</code>表示该方法返回一个 Bean。这样就把<code>TestService</code>作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用<code>@Resource</code>注解注入进来即可使用，非常方便。</p> <div class="language- extra-class"><pre class="language-text"><code>@Resource
private TestService testService;
</code></pre></div><p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p> <h4 id="_2-2-4-简化部署"><a href="#_2-2-4-简化部署" class="header-anchor">#</a> 2.2.4 简化部署</h4> <p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 <code>java -jar xxx.jar</code>一键式启动项目。</p> <p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p> <h4 id="_2-2-5-简化监控"><a href="#_2-2-5-简化监控" class="header-anchor">#</a> 2.2.5 简化监控</h4> <p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p> <h3 id="_2-3-从未来发展的趋势来看"><a href="#_2-3-从未来发展的趋势来看" class="header-anchor">#</a> 2.3 从未来发展的趋势来看</h3> <p>微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。</p> <h2 id="_3-本课程能学到什么"><a href="#_3-本课程能学到什么" class="header-anchor">#</a> 3. 本课程能学到什么</h2> <p>本课程使用目前 Spring Boot 最新版本2.2.6 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。</p> <p>基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。</p> <p>进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。</p> <p>认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。</p> <h2 id="_4-本课程开发环境和插件"><a href="#_4-本课程开发环境和插件" class="header-anchor">#</a> 4.本课程开发环境和插件</h2> <p>本课程的开发环境：</p> <ul><li>开发工具：IDEA 2018</li> <li>JDK版本： JDK 1.8</li> <li>Spring Boot版本：2.2.6 RELEASE</li> <li>Maven版本：3.5.4</li></ul> <p>涉及到的插件：</p> <ul><li>FastJson</li> <li>Swagger2</li> <li>Thymeleaf</li> <li>MyBatis</li> <li>Redis</li> <li>ActiveMQ</li> <li>Shiro</li> <li>Lucence</li></ul> <h2 id="_5-课程目录"><a href="#_5-课程目录" class="header-anchor">#</a> 5. 课程目录</h2> <ul><li>导读：课程概览</li> <li>第01课：Spring Boot开发环境搭建和项目启动</li> <li>第02课：Spring Boot返回Json数据及数据封装</li> <li>第03课：Spring Boot使用slf4j进行日志记录</li> <li>第04课：Spring Boot中的项目属性配置</li> <li>第05课：Spring Boot中的MVC支持</li> <li>第06课：Spring Boot集成Swagger2展现在线接口文档</li> <li>第07课：Spring Boot集成Thymeleaf模板引擎</li> <li>第08课：Spring Boot中的全局异常处理</li> <li>第09课：Spring Boot中的切面AOP处理</li> <li>第10课：Spring Boot中集成MyBatis</li> <li>第11课：Spring Boot事务配置管理</li> <li>第12课：Spring Boot中使用监听器</li> <li>第13课：Spring Boot中使用拦截器</li> <li>第14课：Spring Boot中集成Redis</li> <li>第15课：Spring Boot中集成ActiveMQ</li> <li>第16课：Spring Boot中集成Shiro</li> <li>第17课：Spring Boot中集成Elasticsearch</li> <li>第18课：Spring Boot中集成MP</li> <li>第19课：Spring Boot中集成Redisson</li> <li>第20课：Spring Boot整合jsp</li> <li>第21课：Spring Boot搭建实际项目开发中的架构</li></ul> <h1 id="第01课-spring-boot开发环境搭建和项目启动"><a href="#第01课-spring-boot开发环境搭建和项目启动" class="header-anchor">#</a> 第01课：Spring Boot开发环境搭建和项目启动</h1> <p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p> <h2 id="_1-jdk-的配置"><a href="#_1-jdk-的配置" class="header-anchor">#</a> 1. jdk 的配置</h2> <p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200902153747684.png" alt="image-20200902153747684"></p> <ol><li>选择 SDKs</li> <li>在 JDK home path 中选择本地 jdk 的安装目录</li> <li>在 Name 中为 jdk 自定义名字</li></ol> <p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的弟弟，可以通过两步骤添加：</p> <ul><li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li> <li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li></ul> <h2 id="_2-spring-boot-工程的构建"><a href="#_2-spring-boot-工程的构建" class="header-anchor">#</a> 2. Spring Boot 工程的构建</h2> <h3 id="_2-1-idea-快速构建"><a href="#_2-1-idea-快速构建" class="header-anchor">#</a> 2.1 IDEA 快速构建</h3> <p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p> <ul><li>Group：填企业域名，本课程使用com.glls</li> <li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li> <li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li></ul> <h3 id="_2-2-官方构建"><a href="#_2-2-官方构建" class="header-anchor">#</a> 2.2 官方构建</h3> <p>第二种方式可以通过官方构建，步骤如下：</p> <ul><li>访问 http://start.spring.io/。</li> <li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li></ul> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200904155750073.png" alt="image-20200904155750073" style="zoom:80%;"> <p>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的弟弟，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</p> <h3 id="_2-3-maven配置"><a href="#_2-3-maven配置" class="header-anchor">#</a> 2.3 maven配置</h3> <p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200904160025552.png" alt="image-20200904160025552" style="zoom:80%;"> <p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;mirror&gt;
	&lt;id&gt;nexus-aliyun&lt;/id&gt;
	&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
	&lt;name&gt;Nexus aliyun&lt;/name&gt;
	&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre></div><h3 id="_2-4-编码配置"><a href="#_2-4-编码配置" class="header-anchor">#</a> 2.4 编码配置</h3> <p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p> <p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200904160223823.png" alt="image-20200904160223823" style="zoom:80%;"> <h2 id="_3-spring-boot-项目工程结构"><a href="#_3-spring-boot-项目工程结构" class="header-anchor">#</a> 3. Spring Boot 项目工程结构</h2> <p>Spring Boot 项目总共有三个模块，如下图所示：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200904160553973.png" alt="image-20200904160553973" style="zoom:80%;"> <ul><li><p>src/main/java路径：主要编写业务程序</p></li> <li><p>src/main/resources路径：存放静态文件和配置文件</p></li> <li><p>src/test/java路径：主要编写测试程序</p> <p>默认情况下，如上图所示会创建一个启动类 SpringbootDemo1Application，该类上面有个<code>@SpringBootApplication</code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p></li></ul> <p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下，先添加web依赖：</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
@RequestMapping(&quot;/start&quot;)
public class StartController {
    @RequestMapping(&quot;/springboot&quot;)
    public String startSpringBoot() {
        return &quot;Welcome to the world of Spring Boot!&quot;;
    }
}

</code></pre></div><p>运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p> <div class="language- extra-class"><pre class="language-text"><code>server:
  port: 8001
</code></pre></div><h2 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4. 总结</h2> <p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。</p> <h1 id="第02课-spring-boot返回json数据及数据封装"><a href="#第02课-spring-boot返回json数据及数据封装" class="header-anchor">#</a> 第02课：Spring Boot返回Json数据及数据封装</h1> <p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code>@RestController</code>注解即可返回 Json 格式的数据，<code>@RestController</code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p> <div class="language- extra-class"><pre class="language-text"><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    String value() default &quot;&quot;;
}
</code></pre></div><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的弟弟对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code>@RestController</code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p> <div class="language- extra-class"><pre class="language-text"><code> &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;
      &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre></div><p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
      &lt;version&gt;2.11.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;
      &lt;version&gt;2.11.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
      &lt;version&gt;2.11.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;
      &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;
      &lt;version&gt;2.11.2&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre></div><p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p> <h2 id="_1-spring-boot-默认对json的处理"><a href="#_1-spring-boot-默认对json的处理" class="header-anchor">#</a> 1. Spring Boot 默认对Json的处理</h2> <p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p> <h3 id="_1-1-创建-user-实体类"><a href="#_1-1-创建-user-实体类" class="header-anchor">#</a> 1.1 创建 User 实体类</h3> <p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p> <div class="language- extra-class"><pre class="language-text"><code>public class User {
    private Long id;
    private String username;
    private String password;
	/* 省略get、set和带参构造方法 */
}
</code></pre></div><h3 id="_1-2-创建controller类"><a href="#_1-2-创建controller类" class="header-anchor">#</a> 1.2 创建Controller类</h3> <p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p> <h3 id="_1-3-测试不同数据类型返回的json"><a href="#_1-3-测试不同数据类型返回的json" class="header-anchor">#</a> 1.3 测试不同数据类型返回的json</h3> <p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p> <p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{&quot;id&quot;:1,&quot;username&quot;:&quot;glls&quot;,&quot;password&quot;:&quot;123456&quot;}
</code></pre></div><p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>[{&quot;id&quot;:1,&quot;username&quot;:&quot;glls&quot;,&quot;password&quot;:&quot;123456&quot;},{&quot;id&quot;:2,&quot;username&quot;:&quot;凯&quot;,&quot;password&quot;:&quot;123456&quot;}]
</code></pre></div><p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{&quot;英雄信息&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;glls&quot;,&quot;password&quot;:&quot;123456&quot;},&quot;职业&quot;:&quot;战士&quot;,&quot;性别&quot;:&quot;男&quot;,&quot;年龄&quot;:28}
</code></pre></div><p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p> <h3 id="_1-4-jackson-中对null的处理"><a href="#_1-4-jackson-中对null的处理" class="header-anchor">#</a> 1.4 jackson 中对null的处理</h3> <p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 &quot;&quot; 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>glls<span class="token punctuation">.</span>springbootdemo1<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">JsonGenerator</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">JsonSerializer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">ObjectMapper</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">SerializerProvider</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>condition<span class="token punctuation">.</span></span><span class="token class-name">ConditionalOnMissingBean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Primary</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>json<span class="token punctuation">.</span></span><span class="token class-name">Jackson2ObjectMapperBuilder</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@Primary</span>  <span class="token comment">//简单的说  就是 当Spring 容器扫描到某个接口有多个bean 时， 如果某个bean 上有 @Primary 注解 则这个bean 会被优先选用</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ObjectMapper</span> <span class="token function">jacksonObjectMapper</span><span class="token punctuation">(</span><span class="token class-name">Jackson2ObjectMapperBuilder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ObjectMapper</span> objectMapper <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">createXmlMapper</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectMapper<span class="token punctuation">.</span><span class="token function">getSerializerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNullValueSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JsonSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">JsonGenerator</span> jsonGenerator<span class="token punctuation">,</span> <span class="token class-name">SerializerProvider</span> serializerProvider<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
                jsonGenerator<span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> objectMapper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


 <span class="token comment">/*@ConditionalOnMissingBean(ObjectMapper.class)   它是修饰bean 的一个注解  主要实现功能是  当一个bean 被注册后，如果后面
 *  注册相同类型的bean， 就不会成功，他会保证你的这个类型的bean 只有一个，即这个bean 实例只有一个， 当出现相同的bean 时，这个注解
 *  就会出现异常，以此来通知开发人员。
 *@Primary   // 简单的说  就是 当Spring 容器扫描到某个接口有多个bean 时， 如果某个bean 上有 @Primary 注解 则这个bean 会被优先选用
 */</span>
</code></pre></div><p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>  @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/map&quot;</span><span class="token punctuation">)</span>
    public Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> <span class="token function-name function">getMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span>1L, <span class="token string">&quot;glls&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;英雄信息&quot;</span>, user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;职业&quot;</span>, <span class="token string">&quot;战士&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;性别&quot;</span>, null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;年龄&quot;</span>,28 <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;职业&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;战士&quot;</span>,<span class="token string">&quot;英雄信息&quot;</span>:<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;glls&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">}</span>,<span class="token string">&quot;年龄&quot;</span>:28,<span class="token string">&quot;性别&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-使用阿里巴巴fastjson的设置"><a href="#_2-使用阿里巴巴fastjson的设置" class="header-anchor">#</a> 2.使用阿里巴巴FastJson的设置</h2> <h3 id="_2-1-jackson-和-fastjson-的对比"><a href="#_2-1-jackson-和-fastjson-的对比" class="header-anchor">#</a> 2.1 jackson 和 fastJson 的对比</h3> <p>有很多弟弟习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906083119938.png" alt="image-20200906083119938"></p> <p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p> <h3 id="_2-2-fastjson依赖导入"><a href="#_2-2-fastjson依赖导入" class="header-anchor">#</a> 2.2 fastJson依赖导入</h3> <p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.alibaba<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>fastjson<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">1.2</span>.3<span class="token operator"><span class="token file-descriptor important">5</span>&lt;</span>/version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_2-2-使用-fastjson-处理-null"><a href="#_2-2-使用-fastjson-处理-null" class="header-anchor">#</a> 2.2 使用 fastJson 处理 null</h3> <p>注意 fastjson 的配置类  必须 实现 WebMvcConfigurer 重写configureMessageConverters 方法   才能由spring 管理 集成，不像jackson 是天然集成</p> <p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要实现  <code>WebMvcConfigurer</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>glls<span class="token punctuation">.</span>springbootdemo1<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token class-name">SerializerFeature</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>support<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">FastJsonConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>support<span class="token punctuation">.</span>spring<span class="token punctuation">.</span></span><span class="token class-name">FastJsonHttpMessageConverter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">MediaType</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>converter<span class="token punctuation">.</span></span><span class="token class-name">HttpMessageConverter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>config<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebMvcConfigurationSupport</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span></span><span class="token class-name">Charset</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token comment">// </span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyFastJsonConfig</span> <span class="token keyword">extends</span> <span class="token class-name">FastJsonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 使用阿里 FastJson 作为JSON MessageConverter
     * 先排除jackson 的 干扰   ，从依赖里面 把jackson 排除掉
     &lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
					&lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
     * @param converters
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureMessageConverters</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpMessageConverter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> converters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">FastJsonHttpMessageConverter</span> converter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastJsonHttpMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">MyFastJsonConfig</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyFastJsonConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config<span class="token punctuation">.</span><span class="token function">setSerializerFeatures</span><span class="token punctuation">(</span>
                <span class="token comment">// 保留map空的字段</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>WriteMapNullValue</span><span class="token punctuation">,</span>
                <span class="token comment">// 将String类型的null转成&quot;&quot;</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>WriteNullStringAsEmpty</span><span class="token punctuation">,</span>
                <span class="token comment">// 将Number类型的null转成0</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>WriteNullNumberAsZero</span><span class="token punctuation">,</span>
                <span class="token comment">// 将List类型的null转成[]</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>WriteNullListAsEmpty</span><span class="token punctuation">,</span>
                <span class="token comment">// 将Boolean类型的null转成false</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>WriteNullBooleanAsFalse</span><span class="token punctuation">,</span>
                <span class="token comment">// 避免循环引用</span>
                <span class="token class-name">SerializerFeature<span class="token punctuation">.</span>DisableCircularReferenceDetect</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        converter<span class="token punctuation">.</span><span class="token function">setFastJsonConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        converter<span class="token punctuation">.</span><span class="token function">setDefaultCharset</span><span class="token punctuation">(</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MediaType</span><span class="token punctuation">&gt;</span></span> mediaTypeList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = &quot;application/json&quot;</span>
        mediaTypeList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span><span class="token constant">APPLICATION_JSON</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        converter<span class="token punctuation">.</span><span class="token function">setSupportedMediaTypes</span><span class="token punctuation">(</span>mediaTypeList<span class="token punctuation">)</span><span class="token punctuation">;</span>
        converters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="_3-封装统一返回的数据结构"><a href="#_3-封装统一返回的数据结构" class="header-anchor">#</a> 3. 封装统一返回的数据结构</h2> <p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。</p> <h3 id="_3-1-定义统一的-json-结构"><a href="#_3-1-定义统一的-json-结构" class="header-anchor">#</a> 3.1 定义统一的 json 结构</h3> <p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.common<span class="token punctuation">;</span>

public class JsonResult<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>

    private T data<span class="token punctuation">;</span>
    private String code<span class="token punctuation">;</span>
    private String msg<span class="token punctuation">;</span>

    /**
     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！
     */
    public <span class="token function-name function">JsonResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> <span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    /**
     * 若没有数据返回，可以人为指定状态码和提示信息
     * @param code
     * @param msg
     */
    public JsonResult<span class="token punctuation">(</span>String code, String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    /**
     * 有数据返回时，状态码为0，默认提示信息为：操作成功！
     * @param data
     */
    public JsonResult<span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        this.code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> <span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    /**
     * 有数据返回，状态码为0，人为指定提示信息
     * @param data
     * @param msg
     */
    public JsonResult<span class="token punctuation">(</span>T data, String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        this.code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	//<span class="token punctuation">..</span>.  get  <span class="token builtin class-name">set</span> 方法
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_3-2-修改-controller-中的返回值类型及测试"><a href="#_3-2-修改-controller-中的返回值类型及测试" class="header-anchor">#</a> 3.2 修改 Controller 中的返回值类型及测试</h3> <p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.controller.sec02<span class="token punctuation">;</span>

<span class="token function">import</span> com.glls.springbootdemo1.common.JsonResult<span class="token punctuation">;</span>
<span class="token function">import</span> com.glls.springbootdemo1.pojo.User<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RequestMapping<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RestController<span class="token punctuation">;</span>

<span class="token function">import</span> java.util.ArrayList<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.HashMap<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.List<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.Map<span class="token punctuation">;</span>

@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/jsonresult&quot;</span><span class="token punctuation">)</span>
public class JsonResultController <span class="token punctuation">{</span>
    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function-name function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span>1L, <span class="token string">&quot;zs&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/list&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>List<span class="token operator">&gt;</span> <span class="token function-name function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> userList <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user1 <span class="token operator">=</span> new User<span class="token punctuation">(</span>1l, <span class="token string">&quot;ZS&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user2 <span class="token operator">=</span> new User<span class="token punctuation">(</span>2l, <span class="token string">&quot;LS&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        userList.add<span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        userList.add<span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>userList, <span class="token string">&quot;获取用户列表成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/map&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>Map<span class="token operator">&gt;</span> <span class="token function-name function">getMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span>1L, <span class="token string">&quot;ZS&quot;</span>, null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;英雄信息&quot;</span>, user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;职业&quot;</span>, <span class="token string">&quot;战士&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;性别&quot;</span>, null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;年龄&quot;</span>,28 <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;data&quot;</span>:<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;zs&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">}</span>,<span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;0&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;data&quot;</span>:<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;ZS&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:2,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;LS&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>,<span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;0&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;获取用户列表成功&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;data&quot;</span>:<span class="token punctuation">{</span><span class="token string">&quot;职业&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;战士&quot;</span>,<span class="token string">&quot;英雄信息&quot;</span>:<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;ZS&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>,<span class="token string">&quot;年龄&quot;</span>:28,<span class="token string">&quot;性别&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>,<span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;0&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p> <h2 id="_4-总结-2"><a href="#_4-总结-2" class="header-anchor">#</a> 4. 总结</h2> <p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。</p> <h1 id="第03课-spring-boot使用slf4j进行日志记录"><a href="#第03课-spring-boot使用slf4j进行日志记录" class="header-anchor">#</a> 第03课：Spring Boot使用slf4j进行日志记录</h1> <p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p> <h2 id="_1-slf4j-介绍"><a href="#_1-slf4j-介绍" class="header-anchor">#</a> 1. slf4j 介绍</h2> <p>引用百度百科里的一段话：</p> <blockquote><p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p></blockquote> <p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p> <p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p> <blockquote><p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote> <p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">import</span> org.slf4j.Logger<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.LoggerFactory<span class="token punctuation">;</span>

public class Test <span class="token punctuation">{</span>
    private static final Logger logger <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>Test.class<span class="token punctuation">)</span><span class="token punctuation">;</span>
    // ……
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-application-yml-中对日志的配置"><a href="#_2-application-yml-中对日志的配置" class="header-anchor">#</a> 2. application.yml 中对日志的配置</h2> <p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较喜欢用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p> <p>我们看一下 application.yml 文件中对日志的配置：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>logging:
  config:
    classpath: logback.xml
  level:
    com.glls.springbootdemo1.mapper: trace
</code></pre></div><p>logging.config 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 logback.xml 文件，关于日志的相关配置信息，都放在 logback.xml 文件中了。logging.level 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 com.glls.springbootdemo1.mapper 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p> <p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p> <h2 id="_3-logback-xml-配置文件解析"><a href="#_3-logback-xml-配置文件解析" class="header-anchor">#</a> 3. logback.xml 配置文件解析</h2> <p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p> <h3 id="_3-1-定义日志输出格式和存储路径"><a href="#_3-1-定义日志输出格式和存储路径" class="header-anchor">#</a> 3.1 定义日志输出格式和存储路径</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>configuration<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>property <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;LOG_PATTERN&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot;</span> /<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>property <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;FILE_PATH&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;F:/logs/springboot-demo1/demo.%d{yyyy-MM-dd}.%i.log&quot;</span> /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/configuration<span class="token operator">&gt;</span>
</code></pre></div><p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code>  表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p> <p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p> <h3 id="_3-2-定义控制台输出"><a href="#_3-2-定义控制台输出" class="header-anchor">#</a> 3.2 定义控制台输出</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>configuration<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>appender <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;CONSOLE&quot;</span> <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span><span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>encoder<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的LOG_PATTERN来打印日志 --<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>pattern<span class="token operator">&gt;</span><span class="token variable">${LOG_PATTERN}</span><span class="token operator">&lt;</span>/pattern<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/encoder<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>/appender<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/configuration<span class="token operator">&gt;</span>
</code></pre></div><p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p> <h3 id="_3-3-定义日志文件的相关参数"><a href="#_3-3-定义日志文件的相关参数" class="header-anchor">#</a> 3.3 定义日志文件的相关参数</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>configuration<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>appender <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;FILE&quot;</span> <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span><span class="token operator">!</span>-- 日志记录器的滚动策略，按日期，按大小记录 --<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>rollingPolicy <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span><span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的FILE_PATH路径来保存日志 --<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>fileNamePattern<span class="token operator">&gt;</span><span class="token variable">${FILE_PATH}</span><span class="token operator">&lt;</span>/fileNamePattern<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span><span class="token operator">!</span>-- 日志保存15天 --<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>maxHistory<span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator"><span class="token file-descriptor important">5</span>&lt;</span>/maxHistory<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>timeBasedFileNamingAndTriggeringPolicy <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span><span class="token operator">&gt;</span>
				<span class="token operator">&lt;</span><span class="token operator">!</span>-- 单个日志文件的最大，超过则新建日志文件存储 --<span class="token operator">&gt;</span>
				<span class="token operator">&lt;</span>maxFileSize<span class="token operator">&gt;</span>10MB<span class="token operator">&lt;</span>/maxFileSize<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>/timeBasedFileNamingAndTriggeringPolicy<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/rollingPolicy<span class="token operator">&gt;</span>

		<span class="token operator">&lt;</span>encoder<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的LOG_PATTERN来打印日志 --<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>pattern<span class="token operator">&gt;</span><span class="token variable">${LOG_PATTERN}</span><span class="token operator">&lt;</span>/pattern<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/encoder<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>/appender<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/configuration<span class="token operator">&gt;</span>
</code></pre></div><p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p> <h3 id="_3-4-定义日志输出级别"><a href="#_3-4-定义日志输出级别" class="header-anchor">#</a> 3.4 定义日志输出级别</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>configuration<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>logger <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;com.glls&quot;</span> <span class="token assign-left variable">level</span><span class="token operator">=</span><span class="token string">&quot;INFO&quot;</span> /<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>root <span class="token assign-left variable">level</span><span class="token operator">=</span><span class="token string">&quot;INFO&quot;</span><span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>appender-ref <span class="token assign-left variable">ref</span><span class="token operator">=</span><span class="token string">&quot;CONSOLE&quot;</span> /<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>appender-ref <span class="token assign-left variable">ref</span><span class="token operator">=</span><span class="token string">&quot;FILE&quot;</span> /<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>/root<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/configuration<span class="token operator">&gt;</span>
</code></pre></div><p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p> <h2 id="_4-使用logger在项目中打印日志"><a href="#_4-使用logger在项目中打印日志" class="header-anchor">#</a> 4. 使用Logger在项目中打印日志</h2> <p>在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.controller.sec03<span class="token punctuation">;</span>

<span class="token function">import</span> org.slf4j.Logger<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.LoggerFactory<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RequestMapping<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RestController<span class="token punctuation">;</span>

@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/log&quot;</span><span class="token punctuation">)</span>
public class LoggerController <span class="token punctuation">{</span>
    private final static Logger logger <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>LoggerController.class<span class="token punctuation">)</span><span class="token punctuation">;</span>
    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/log&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">testLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger.debug<span class="token punctuation">(</span><span class="token string">&quot;=====测试日志debug级别打印====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;======测试日志info级别打印=====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger.error<span class="token punctuation">(</span><span class="token string">&quot;=====测试日志error级别打印====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger.warn<span class="token punctuation">(</span><span class="token string">&quot;======测试日志warn级别打印=====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        // 可以使用占位符打印出一些参数信息
        String str1 <span class="token operator">=</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">;</span>
        String str2 <span class="token operator">=</span> <span class="token string">&quot;28&quot;</span><span class="token punctuation">;</span>
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;用户姓名：{},用户年龄：{}&quot;</span>, str1, str2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>启动该项目，在浏览器中输入 http://localhost:8080/log/log 后可以看到控制台的日志记录：</p> <blockquote><p>2020-09-06 09:37:12.106  INFO 10156 --- [nio-8080-exec-1] c.g.s.controller.sec03.LoggerController  : ======测试日志info级别打印=====
2020-09-06 09:37:12.106 ERROR 10156 --- [nio-8080-exec-1] c.g.s.controller.sec03.LoggerController  : =====测试日志error级别打印====
2020-09-06 09:37:12.106  WARN 10156 --- [nio-8080-exec-1] c.g.s.controller.sec03.LoggerController  : ======测试日志warn级别打印=====
2020-09-06 09:37:12.107  INFO 10156 --- [nio-8080-exec-1] c.g.s.controller.sec03.LoggerController  : 用户姓名：zs,用户年龄：28</p></blockquote> <p>因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 F:\logs\springboot-demo1 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。</p> <h2 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h2> <p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。下面是  logback.xml</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>configuration<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;LOG_PATTERN&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot;</span> /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>property <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;FILE_PATH&quot;</span> <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;F:/logs/springbootdemo1/demo.%d{yyyy-MM-dd}.%i.log&quot;</span> /<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>appender <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;CONSOLE&quot;</span> <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>encoder<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的LOG_PATTERN来打印日志 --<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>pattern<span class="token operator">&gt;</span><span class="token variable">${LOG_PATTERN}</span><span class="token operator">&lt;</span>/pattern<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/encoder<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/appender<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>appender <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;FILE&quot;</span> <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>rollingPolicy <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的FILE_PATH路径来保存日志 --<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>fileNamePattern<span class="token operator">&gt;</span><span class="token variable">${FILE_PATH}</span><span class="token operator">&lt;</span>/fileNamePattern<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 日志保存15天 --<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>maxHistory<span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator"><span class="token file-descriptor important">5</span>&lt;</span>/maxHistory<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>timeBasedFileNamingAndTriggeringPolicy <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">!</span>-- 单个日志文件的最大，超过则新建日志文件存储 --<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>maxFileSize<span class="token operator">&gt;</span>10MB<span class="token operator">&lt;</span>/maxFileSize<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/timeBasedFileNamingAndTriggeringPolicy<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/rollingPolicy<span class="token operator">&gt;</span>

        <span class="token operator">&lt;</span>encoder<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 按照上面配置的LOG_PATTERN来打印日志 --<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>pattern<span class="token operator">&gt;</span><span class="token variable">${LOG_PATTERN}</span><span class="token operator">&lt;</span>/pattern<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/encoder<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/appender<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>logger <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;com.glls&quot;</span> <span class="token assign-left variable">level</span><span class="token operator">=</span><span class="token string">&quot;INFO&quot;</span> /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>root <span class="token assign-left variable">level</span><span class="token operator">=</span><span class="token string">&quot;INFO&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>appender-ref <span class="token assign-left variable">ref</span><span class="token operator">=</span><span class="token string">&quot;CONSOLE&quot;</span> /<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>appender-ref <span class="token assign-left variable">ref</span><span class="token operator">=</span><span class="token string">&quot;FILE&quot;</span> /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/root<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/configuration<span class="token operator">&gt;</span>
</code></pre></div><h1 id="第04课-spring-boot中的项目属性配置"><a href="#第04课-spring-boot中的项目属性配置" class="header-anchor">#</a> 第04课：Spring Boot中的项目属性配置</h1> <p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。</p> <h2 id="_1-少量配置信息的情形"><a href="#_1-少量配置信息的情形" class="header-anchor">#</a> 1. 少量配置信息的情形</h2> <p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>server:
  port: <span class="token number">8001</span>

<span class="token comment"># 配置微服务的地址</span>
url:
  <span class="token comment"># 订单微服务的地址</span>
  orderUrl: http://localhost:8002
</code></pre></div><p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code>@Value</code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code>@Value</code> 注解即可获取到配置文件中的配置信息，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">import</span> org.slf4j.Logger<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.LoggerFactory<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.beans.factory.annotation.Value<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RequestMapping<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RestController<span class="token punctuation">;</span>

@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
public class ConfigController <span class="token punctuation">{</span>

    private static final Logger LOGGER <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>ConfigController.class<span class="token punctuation">)</span><span class="token punctuation">;</span>

    @Value<span class="token punctuation">(</span><span class="token string">&quot;<span class="token variable">${url.orderUrl}</span>&quot;</span><span class="token punctuation">)</span>
    private String orderUrl<span class="token punctuation">;</span>
    
    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/config&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">testConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;=====获取的订单服务地址为：{}&quot;</span>, orderUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>@Value</code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>获取的订单服务地址为：http://localhost:8002
</code></pre></div><p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。</p> <h2 id="_2-多个配置信息的情形"><a href="#_2-多个配置信息的情形" class="header-anchor">#</a> 2.多个配置信息的情形</h2> <p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code>@Value</code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p> <p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 配置多个微服务的地址</span>
url:
  <span class="token comment"># 订单微服务的地址</span>
  orderUrl: http://localhost:8002
  <span class="token comment"># 用户微服务的地址</span>
  userUrl: http://localhost:8003
  <span class="token comment"># 购物车微服务的地址</span>
  shoppingUrl: http://localhost:8004
</code></pre></div><p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Component
@ConfigurationProperties<span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">&quot;url&quot;</span><span class="token punctuation">)</span>
public class MicroServiceUrl <span class="token punctuation">{</span>

    private String orderUrl<span class="token punctuation">;</span>
    private String userUrl<span class="token punctuation">;</span>
    private String shoppingUrl<span class="token punctuation">;</span>
    // 省去get和set方法
<span class="token punctuation">}</span>
</code></pre></div><p>细心的弟弟应该可以看到，使用 <code>@ConfigurationProperties</code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code>@Component</code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p> <p>需要注意的是，使用 <code>@ConfigurationProperties</code> 注解需要导入它的依赖：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-configuration-processor<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>optional<span class="token operator">&gt;</span>true<span class="token operator">&lt;</span>/optional<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code>@Resource</code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.controller<span class="token punctuation">;</span>


<span class="token function">import</span> com.glls.pojo.MicroServiceUrl<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.Logger<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.LoggerFactory<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.beans.factory.annotation.Value<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RequestMapping<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.RestController<span class="token punctuation">;</span>

<span class="token function">import</span> javax.annotation.Resource<span class="token punctuation">;</span>

@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
public class ConfigController <span class="token punctuation">{</span>
    private static final Logger LOGGER <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>ConfigController.class<span class="token punctuation">)</span><span class="token punctuation">;</span>

    @Value<span class="token punctuation">(</span><span class="token string">&quot;<span class="token variable">${boot.name}</span>&quot;</span><span class="token punctuation">)</span>
    private String name<span class="token punctuation">;</span>

    @Resource
    private MicroServiceUrl microServiceUrl<span class="token punctuation">;</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/config&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">testConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;=====获取配置文件中的数据：{}&quot;</span>, name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;=====获取配置文件中的数据：{}&quot;</span>, microServiceUrl.getOrderUrl<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;=====获取配置文件中的数据：{}&quot;</span>, microServiceUrl.getShoppingUrl<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;=====获取配置文件中的数据：{}&quot;</span>, microServiceUrl.getUserUrl<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>获取的订单服务地址为：http://localhost:8002
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>获取的订单服务地址为：http://localhost:8002
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>获取的用户服务地址为：http://localhost:8003
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>获取的购物车服务地址为：http://localhost:8004
</code></pre></div><h2 id="_3-指定项目配置文件"><a href="#_3-指定项目配置文件" class="header-anchor">#</a> 3. 指定项目配置文件</h2> <p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p> <p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p> <p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 开发环境配置文件</span>
server:
  port: <span class="token number">8001</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 生产环境配置文件</span>
server:
  port: <span class="token number">8002</span>
</code></pre></div><p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>spring:
  profiles:
    active:
    - dev
</code></pre></div><p>这样就可以在开发的时候，指定读取  <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p> <h2 id="_4-总结-3"><a href="#_4-总结-3" class="header-anchor">#</a> 4. 总结</h2> <p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。</p> <h1 id="第05课-spring-boot中的mvc支持"><a href="#第05课-spring-boot中的mvc支持" class="header-anchor">#</a> 第05课：Spring Boot中的MVC支持</h1> <p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、<code>@RequestParam</code> 以及 <code>@RequestBody</code>。主要介绍这几个注解常用的使用方式和特点。</p> <h2 id="_1-restcontroller"><a href="#_1-restcontroller" class="header-anchor">#</a> 1. @RestController</h2> <p><code>@RestController</code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Target<span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType.TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>
@Retention<span class="token punctuation">(</span>RetentionPolicy.RUNTIME<span class="token punctuation">)</span>
@Documented
@Controller
@ResponseBody
public @interface RestController <span class="token punctuation">{</span>
    String value<span class="token punctuation">(</span><span class="token punctuation">)</span> default <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的弟弟对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以 <code>@RestController</code> 可以看作是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，相当于偷个懒，我们使用 <code>@RestController</code> 之后就不用再使用 <code>@Controller</code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code>@RestController</code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code>@RestController</code>了，比如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public String <span class="token function-name function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;user&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实是需要返回到 user.html 页面的，如果使用 <code>@RestController</code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code>@Controller</code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p> <h2 id="_2-requestmapping"><a href="#_2-requestmapping" class="header-anchor">#</a> 2. @RequestMapping</h2> <p><code>@RequestMapping</code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p> <p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p> <ul><li>value 属性：指定请求的实际地址，value 可以省略不写</li> <li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li> <li>produces属性：指定返回内容类型，如 produces = &quot;application/json; charset=UTF-8&quot;</li></ul> <p><code>@RequestMapping</code> 注解比较简单，举个例子：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@RestController
@RequestMapping<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/test&quot;</span>, produces <span class="token operator">=</span> <span class="token string">&quot;application/json; charset=UTF-8&quot;</span><span class="token punctuation">)</span>
public class TestController <span class="token punctuation">{</span>

    @RequestMapping<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/get&quot;</span>, method <span class="token operator">=</span> RequestMethod.GET<span class="token punctuation">)</span>
    public String <span class="token function-name function">testGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p> <p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code>@RequestMapping</code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code>@GetMapping(&quot;/get&quot;)</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</p> <h2 id="_3-pathvariable"><a href="#_3-pathvariable" class="header-anchor">#</a> 3. @PathVariable</h2> <p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/user/{id}&quot;</span><span class="token punctuation">)</span>
public String testPathVariable<span class="token punctuation">(</span>@PathVariable Integer <span class="token function">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的id为：&quot;</span> + <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code>@PathVariable</code> 中的 value 属性来指定对应关系。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/user/{idd}&quot;</span><span class="token punctuation">)</span>
public String testPathVariable<span class="token punctuation">(</span>@PathVariable<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;idd&quot;</span><span class="token punctuation">)</span> Integer <span class="token function">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的id为：&quot;</span> + <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/user/{idd}/{name}&quot;</span><span class="token punctuation">)</span>
    public String testPathVariable<span class="token punctuation">(</span>@PathVariable<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;idd&quot;</span><span class="token punctuation">)</span> Integer id, @PathVariable String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的id为：&quot;</span> + <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的name为：&quot;</span> + name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>获取到的id为：2
获取到的name为：zhangsan
</code></pre></div><p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p> <h2 id="_4-requestparam"><a href="#_4-requestparam" class="header-anchor">#</a> 4. @RequestParam</h2> <p><code>@RequestParam</code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code>@PathValiable</code> 注解也是获取请求参数的，那么 <code>@RequestParam</code> 和 <code>@PathVariable</code> 有什么不同呢？主要区别在于： <code>@PathValiable</code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code>@RequestParam</code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code>  。我们使用该 url 带上参数 id 来测试一下如下代码：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
public String testRequestParam<span class="token punctuation">(</span>@RequestParam Integer <span class="token function">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的id为：&quot;</span> + <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p> <div class="language-shell extra-class"><pre class="language-shell"><code>@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
public String testRequestParam<span class="token punctuation">(</span>@RequestParam<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;idd&quot;</span>, required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> Integer <span class="token function">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的id为：&quot;</span> + <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了 value 属性外，还有个两个属性比较常用：</p> <ul><li>required 属性：true 表示该参数必须要传，否则就会报 400 错误，false 表示可有可无。</li> <li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li></ul> <p>从 url 中可以看出，<code>@RequestParam</code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code>@RequestParam</code> 来接收，用法和上面一样。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/form1&quot;</span><span class="token punctuation">)</span>
    public String testForm<span class="token punctuation">(</span>@RequestParam String username, @RequestParam String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的username为：&quot;</span> + username<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的password为：&quot;</span> + password<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906103435559.png" alt="image-20200906103435559" style="zoom:80%;"> <p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code>@RequestParam</code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public class User <span class="token punctuation">{</span>
	private String username<span class="token punctuation">;</span>
	private String password<span class="token punctuation">;</span>
	// <span class="token builtin class-name">set</span> get
<span class="token punctuation">}</span>
</code></pre></div><p>使用实体接收的话，我们不能在前面加 <code>@RequestParam</code> 注解了，直接使用即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/form2&quot;</span><span class="token punctuation">)</span>
    public String testForm<span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的username为：&quot;</span> + user.getUsername<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的password为：&quot;</span> + user.getPassword<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多</p> <h2 id="_5-requestbody"><a href="#_5-requestbody" class="header-anchor">#</a> 5. @RequestBody</h2> <p><code>@RequestBody</code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code>@RequestBody</code> 接收会非常方便。例如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public class User <span class="token punctuation">{</span>
	private String username<span class="token punctuation">;</span>
	private String password<span class="token punctuation">;</span>
	// <span class="token builtin class-name">set</span> get
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>@PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
public String testRequestBody<span class="token punctuation">(</span>@RequestBody User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的username为：&quot;</span> + user.getUsername<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
	System.out.println<span class="token punctuation">(</span><span class="token string">&quot;获取到的password为：&quot;</span> + user.getPassword<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906104205055.png" alt="image-20200906104205055" style="zoom:80%;"> <p>同时看一下后台控制台输出的日志：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>获取到的username为：张三
获取到的password为：123
</code></pre></div><p>可以看出，<code>@RequestBody</code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p> <h2 id="_6-总结"><a href="#_6-总结" class="header-anchor">#</a> 6. 总结</h2> <p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、 <code>@RequestParam</code> 和 <code>@RequestBody</code> 四个注解的使用方式，由于 <code>@RestController</code> 中集成了 <code>@ResponseBody</code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p> <h1 id="第06课-spring-boot集成-swagger2-展现在线接口文档"><a href="#第06课-spring-boot集成-swagger2-展现在线接口文档" class="header-anchor">#</a> 第06课：Spring Boot集成 Swagger2 展现在线接口文档</h1> <h2 id="_1-swagger-简介"><a href="#_1-swagger-简介" class="header-anchor">#</a> 1. Swagger 简介</h2> <h3 id="_1-1-解决的问题"><a href="#_1-1-解决的问题" class="header-anchor">#</a> 1.1 解决的问题</h3> <p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p> <p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p> <h3 id="_1-2-swagger-官方"><a href="#_1-2-swagger-官方" class="header-anchor">#</a> 1.2 Swagger 官方</h3> <p>我们打开 <a href="https://swagger.io/" target="_blank" rel="noopener noreferrer">Swagger 官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，官方对 Swagger 的定义为：</p> <blockquote><p>The Best APIs are Built with Swagger Tools</p></blockquote> <p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200904173138857.png" alt="image-20200904173138857" style="zoom:80%;"> <p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p> <h2 id="_2-swagger2-的-maven-依赖"><a href="#_2-swagger2-的-maven-依赖" class="header-anchor">#</a> 2. Swagger2 的 maven 依赖</h2> <p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 xxx，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.9.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.9.2 版本来展开，依赖如下：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
	&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
	&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div><h2 id="_3-swagger2-的配置"><a href="#_3-swagger2-的配置" class="header-anchor">#</a> 3. Swagger2 的配置</h2> <p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code>@Configuration</code> 注解外，还需要添加 <code>@EnableSwagger2</code> 注解。</p> <div class="language- extra-class"><pre class="language-text"><code>package com.glls.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {
     @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                // 指定构建api文档的详细信息的方法：apiInfo()
                .apiInfo(apiInfo())
                .select()
                // 为当前包下controller生成API文档
                //.apis(RequestHandlerSelectors.basePackage(&quot;com.ww.springbootdemo2.sec06&quot;))
                //为有@Api注解的Controller生成API文档
                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))
                //为有@ApiOperation注解的方法生成API文档
                //.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                //为任何接口生成API文档
                //.apis(RequestHandlerSelectors.any())

                //paths： 这里是控制哪些路径的api会被显示出来，比如下方的参数就是除了/user以外的其它路径都会生成api文档
                //.paths((String a) -&gt;
                //        !a.equals(&quot;/user/{id}&quot;))
                .paths(PathSelectors.any())   // 路径过滤  ,当前配置是所有罗静 都生成api 文档
                .build();
    }


    /**
     * 构建api文档的详细信息
     *
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                // 设置页面标题
                .title(&quot;Spring Boot集成Swagger2接口总览&quot;)
                // 设置接口描述
                .description(&quot;Spring Boot集成swagger&quot;)

                // 设置联系方式
                .contact(new Contact(&quot;xxx&quot;, &quot;xxx&quot;, &quot;123@qq.com&quot;))
                // 设置版本
                .version(&quot;1.0&quot;)
                // 构建
                .build();
    }

}

</code></pre></div><p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906105034636.png" alt="image-20200906105034636" style="zoom:80%;"> <p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p> <h2 id="_4-swagger2-的使用"><a href="#_4-swagger2-的使用" class="header-anchor">#</a> 4. Swagger2 的使用</h2> <p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p> <h3 id="_4-1-实体类注解"><a href="#_4-1-实体类注解" class="header-anchor">#</a> 4.1 实体类注解</h3> <p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解，同时为后面的测试做准备。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">import</span> io.swagger.annotations.ApiModel<span class="token punctuation">;</span>
<span class="token function">import</span> io.swagger.annotations.ApiModelProperty<span class="token punctuation">;</span>

@ApiModel<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户实体类&quot;</span><span class="token punctuation">)</span>
public class User <span class="token punctuation">{</span>

    @ApiModelProperty<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户唯一标识&quot;</span><span class="token punctuation">)</span>
    private Long <span class="token function">id</span><span class="token punctuation">;</span>

    @ApiModelProperty<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户姓名&quot;</span><span class="token punctuation">)</span>
    private String username<span class="token punctuation">;</span>

    @ApiModelProperty<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户密码&quot;</span><span class="token punctuation">)</span>
    private String password<span class="token punctuation">;</span>

	// 省略set和get方法
<span class="token punctuation">}</span>
</code></pre></div><p>解释下 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解：</p> <blockquote><p><code>@ApiModel</code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。
<code>@ApiModelProperty</code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p></blockquote> <p>该注解在在线 API 文档中的具体效果在下文说明。</p> <h3 id="_4-2-controller-类中相关注解"><a href="#_4-2-controller-类中相关注解" class="header-anchor">#</a> 4.2 Controller 类中相关注解</h3> <p>我们写一个 SwaggerController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.controller.sec06<span class="token punctuation">;</span>


<span class="token function">import</span> com.glls.springbootdemo1.common.JsonResult<span class="token punctuation">;</span>
<span class="token function">import</span> com.glls.springbootdemo1.pojo.User<span class="token punctuation">;</span>
<span class="token function">import</span> io.swagger.annotations.*<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.*<span class="token punctuation">;</span>

@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/swagger&quot;</span><span class="token punctuation">)</span>
@Api<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;Swagger2 在线接口文档&quot;</span><span class="token punctuation">)</span>
public class SwaggerController <span class="token punctuation">{</span>

    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/get/{id}&quot;</span><span class="token punctuation">)</span>
    @ApiImplicitParams<span class="token punctuation">(</span><span class="token punctuation">{</span>@ApiImplicitParam<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;id&quot;</span>,value <span class="token operator">=</span> <span class="token string">&quot;用户id&quot;</span>,defaultValue <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    @ApiOperation<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;根据用户唯一标识获取用户信息&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> getUserInfo<span class="token punctuation">(</span>@PathVariable @ApiParam<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户唯一标识&quot;</span><span class="token punctuation">)</span> Long <span class="token function">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 模拟数据库中根据id获取User信息
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span>id, <span class="token string">&quot;zs&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/insert&quot;</span><span class="token punctuation">)</span>
    @ApiOperation<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;添加用户信息&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> insertUser<span class="token punctuation">(</span>@RequestBody @ApiParam<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户信息&quot;</span><span class="token punctuation">)</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 处理添加逻辑

        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>我们来学习一下 <code>@Api</code> 、 <code>@ApiOperation</code> 和 <code>@ApiParam</code> 注解。</p> <blockquote><p><code>@Api</code> 注解用于类上，表示标识这个类是 swagger 的资源。
<code>@ApiOperation</code> 注解用于方法，表示一个 http 请求的操作。
<code>@ApiParam</code> 注解用于参数上，用来标明参数信息。</p></blockquote> <p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906110657628.png" alt="image-20200906110657628"></p> <p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为2，看一下返回数据：</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906110752646.png" alt="image-20200906110752646" style="zoom:80%;"> <p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>  @PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/insert&quot;</span><span class="token punctuation">)</span>
    @ApiOperation<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;添加用户信息&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> insertUser<span class="token punctuation">(</span>@RequestBody @ApiParam<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户信息&quot;</span><span class="token punctuation">)</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 处理添加逻辑

        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906110912296.png" alt="image-20200906110912296" style="zoom:80%;"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906110956392.png" alt="image-20200906110956392"></p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906111043781.png" alt="image-20200906111043781" style="zoom:80%;"> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906111056471.png" alt="image-20200906111056471" style="zoom:80%;"> <h3 id="_4-3把swagger2的api接口导入postman"><a href="#_4-3把swagger2的api接口导入postman" class="header-anchor">#</a> 4.3把Swagger2的API接口导入Postman</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token number">1</span>、访问http://localhost:8080/swagger-ui.html 文档的首页，复制下面这个地址
</code></pre></div><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210319115609837.png" alt="image-20210319115609837"></p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token number">2</span>.打开postman--<span class="token operator">&gt;</span>import--<span class="token operator">&gt;</span>import Form Link
</code></pre></div><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210319115719822.png" alt="image-20210319115719822"></p> <p>导入成功</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210319115753092.png" alt="image-20210319115753092"></p> <p>注意 这里的 baseUrl 变量 ，可能需要编辑</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210319115849542.png" alt="image-20210319115849542"></p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210319115906616.png" alt="image-20210319115906616"></p> <h3 id="_4-4-配置swagger-之后-访问-swagger-ui-html-出现-404-解决方案"><a href="#_4-4-配置swagger-之后-访问-swagger-ui-html-出现-404-解决方案" class="header-anchor">#</a> 4.4  配置swagger 之后 访问 swagger-ui.html 出现  404   解决方案</h3> <blockquote><p>WebMvcConfigurer  这个 接口很关键    MVC 的  核心配置实现</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 让拦截器 释放swagger 静态资源</span>
        <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//registry.addInterceptor(localInterceptor())</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/swagger-resources/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/webjars/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/v2/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/swagger-ui.html/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>swagger-ui 页面 会发送一个安全相关的 请求   /csrf    ,是为了 接口的安全性  添加的    安全token 检验， 这里咱们添加一个接口，来接受这个请求，避免报 404 错误</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CSRFController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/csrf&quot;</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> produces <span class="token operator">=</span> <span class="token string">&quot;application/json;charset=UTF-8&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CsrfToken</span><span class="token punctuation">&gt;</span></span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpSessionCsrfTokenRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generateToken</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>  <span class="token operator">/</span>csrf 请求 实现 所需要的 依赖<span class="token operator">--</span><span class="token operator">&gt;</span>
		<span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
			<span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>security<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
			<span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>spring<span class="token operator">-</span>security<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>

</code></pre></div><h2 id="_5-总结-2"><a href="#_5-总结-2" class="header-anchor">#</a> 5. 总结</h2> <p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p> <h1 id="第07课-spring-boot集成thymeleaf模板引擎"><a href="#第07课-spring-boot集成thymeleaf模板引擎" class="header-anchor">#</a> 第07课：Spring Boot集成Thymeleaf模板引擎</h1> <h2 id="_1-thymeleaf-介绍"><a href="#_1-thymeleaf-介绍" class="header-anchor">#</a> 1.Thymeleaf 介绍</h2> <blockquote><p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>
Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。</p></blockquote> <p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。</p> <p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>div <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ui right aligned basic segment&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ui orange basic label&quot;</span> th:text<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blog.flag}</span>&quot;</span><span class="token operator">&gt;</span>静态原创信息<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>h2 <span class="token assign-left variable">class</span><span class="token operator">=</span><span class="token string">&quot;ui center aligned header&quot;</span> th:text<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blog.title}</span>&quot;</span><span class="token operator">&gt;</span>这是静态标题<span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
</code></pre></div><p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。</p> <h2 id="_2-依赖导入"><a href="#_2-依赖导入" class="header-anchor">#</a> 2. 依赖导入</h2> <p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter-thymeleaf<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>html xmlns:th<span class="token operator">=</span><span class="token string">&quot;http://www.thymeleaf.org&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="_3-thymeleaf相关配置"><a href="#_3-thymeleaf相关配置" class="header-anchor">#</a> 3. Thymeleaf相关配置</h2> <p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>spring:
  thymeleaf:
    cache: <span class="token boolean">false</span> <span class="token comment">#关闭缓存</span>
</code></pre></div><p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p> <h2 id="_4-thymeleaf-的使用"><a href="#_4-thymeleaf-的使用" class="header-anchor">#</a> 4. Thymeleaf 的使用</h2> <h3 id="_4-1-访问静态页面"><a href="#_4-1-访问静态页面" class="header-anchor">#</a> 4.1 访问静态页面</h3> <p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html <span class="token assign-left variable">lang</span><span class="token operator">=</span><span class="token string">&quot;en&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">&quot;UTF-8&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Title<span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    这是404页面
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre></div><p>我们再写一个 controller 来测试一下 404 和 500 页面：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Controller
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/thy&quot;</span><span class="token punctuation">)</span>
public class ThymeleafController <span class="token punctuation">{</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/test404&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">test404</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;index&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/test500&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">test500</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int i <span class="token operator">=</span> <span class="token number">1</span> / <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;index&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>当我们在浏览器中输入 <code>localhost:8080/thy/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>
当我们在浏览器中输入 <code>localhost:8088/thy/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p></blockquote> <p>【注】这里有个问题需要注意一下，前面我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code>@RestController</code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code>@RestController</code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code>@RestController</code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code>@Controller</code> 注解。</p> <h3 id="_4-2-thymeleaf-中处理对象"><a href="#_4-2-thymeleaf-中处理对象" class="header-anchor">#</a> 4.2 Thymeleaf 中处理对象</h3> <p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public class Blogger <span class="token punctuation">{</span>
    private Long <span class="token function">id</span><span class="token punctuation">;</span>
    private String name<span class="token punctuation">;</span>
    private String pass<span class="token punctuation">;</span>
	// 省去set和get
<span class="token punctuation">}</span>
</code></pre></div><p>然后在controller层中初始化一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>  @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/getBlogger&quot;</span><span class="token punctuation">)</span>
    public String getBlogger<span class="token punctuation">(</span>Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Blogger blogger <span class="token operator">=</span> new Blogger<span class="token punctuation">(</span>1L, <span class="token string">&quot;zs&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        model.addAttribute<span class="token punctuation">(</span><span class="token string">&quot;blogger&quot;</span>, blogger<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;blog/blogger&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
 
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">&quot;UTF-8&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Title<span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>form <span class="token assign-left variable">action</span><span class="token operator">=</span><span class="token string">&quot;&quot;</span> th:object<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger}</span>&quot;</span> <span class="token operator">&gt;</span>
    用户编号：<span class="token operator">&lt;</span>input <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;id&quot;</span> th:value<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger.id}</span>&quot;</span>/<span class="token operator">&gt;</span><span class="token operator">&lt;</span>br<span class="token operator">&gt;</span>
    用户姓名：<span class="token operator">&lt;</span>input <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;username&quot;</span> th:value<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger.getName()}</span>&quot;</span> /<span class="token operator">&gt;</span><span class="token operator">&lt;</span>br<span class="token operator">&gt;</span>
    登陆密码：<span class="token operator">&lt;</span>input <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;password&quot;</span> th:value<span class="token operator">=</span><span class="token string">&quot;*{pass}&quot;</span> /<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/form<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre></div><p>可以看出，在 thymeleaf 模板中，使用 <code>th:object=&quot;${}&quot;</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p> <blockquote><p>使用 <code>th:value=&quot;*{属性名}&quot;</code>
使用 <code>th:value=&quot;${对象.属性名}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象
使用 <code>th:value=&quot;${对象.get方法}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p></blockquote> <p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thy/getBlogger</code> 来测试一下数据：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200926184335686.png" alt="image-20200926184335686"></p> <h3 id="_4-3-thymeleaf-中处理-list"><a href="#_4-3-thymeleaf-中处理-list" class="header-anchor">#</a> 4.3 Thymeleaf 中处理 List</h3> <p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>   @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/getList&quot;</span><span class="token punctuation">)</span>
    public String getList<span class="token punctuation">(</span>Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Blogger blogger1 <span class="token operator">=</span> new Blogger<span class="token punctuation">(</span>1L, <span class="token string">&quot;zs&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Blogger blogger2 <span class="token operator">=</span> new Blogger<span class="token punctuation">(</span>2L, <span class="token string">&quot;ls&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>Blogger<span class="token operator">&gt;</span> list <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list.add<span class="token punctuation">(</span>blogger1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list.add<span class="token punctuation">(</span>blogger2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        model.addAttribute<span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span>, list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;blog/list&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html <span class="token assign-left variable">lang</span><span class="token operator">=</span><span class="token string">&quot;en&quot;</span> xmlns:th<span class="token operator">=</span><span class="token string">&quot;http://www.thymeleaf.org&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>meta <span class="token assign-left variable">charset</span><span class="token operator">=</span><span class="token string">&quot;UTF-8&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Title<span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>script <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> <span class="token assign-left variable">src</span><span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>th<span class="token operator">&gt;</span>用户编号<span class="token operator">&lt;</span>/th<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>th<span class="token operator">&gt;</span>用户姓名<span class="token operator">&lt;</span>/th<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>th<span class="token operator">&gt;</span>密码<span class="token operator">&lt;</span>/th<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr th:each<span class="token operator">=</span><span class="token string">&quot;blogger : <span class="token variable">${list}</span>&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>td th:text<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger.id}</span>&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>td th:text<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger.name}</span>&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>td th:text<span class="token operator">=</span><span class="token string">&quot;<span class="token variable">${blogger.pass}</span>&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/td<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/tr<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>/table<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>
</code></pre></div><p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。</p> <h3 id="_4-4-其他常用-thymeleaf-操作"><a href="#_4-4-其他常用-thymeleaf-操作" class="header-anchor">#</a> 4.4 其他常用 thymeleaf 操作</h3> <p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p> <table><thead><tr><th>标签</th> <th>功能</th> <th>例子</th></tr></thead> <tbody><tr><td><code>th:value</code></td> <td>给属性赋值</td> <td><code>&lt;input th:value=&quot;${blog.name}&quot; /&gt;</code></td></tr> <tr><td><code>th:style</code></td> <td>设置样式</td> <td><code>th:style=&quot;'display:'+@{(${sitrue}?'none':'inline-block')} + ''&quot;</code></td></tr> <tr><td><code>th:onclick</code></td> <td>点击事件</td> <td><code>th:onclick=&quot;'getInfo()'&quot;</code></td></tr> <tr><td><code>th:if</code></td> <td>条件判断</td> <td><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td></tr> <tr><td><code>th:href</code></td> <td>超链接</td> <td><code>&lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt;</code></td></tr> <tr><td><code>th:unless</code></td> <td>条件判断和<code>th:if</code>相反</td> <td><code>&lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td></tr> <tr><td><code>th:switch</code></td> <td>配合<code>th:case</code></td> <td><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td></tr> <tr><td><code>th:case</code></td> <td>配合<code>th:switch</code></td> <td><code>&lt;p th:case=&quot;'admin'&quot;&gt;administator&lt;/p&gt;</code></td></tr> <tr><td><code>th:src</code></td> <td>地址引入</td> <td><code>&lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td></tr> <tr><td><code>th:action</code></td> <td>表单提交的地址</td> <td><code>&lt;form th:action=&quot;@{/blogger/update}&quot;&gt;</code></td></tr></tbody></table> <p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener noreferrer">官方文档（v3.0）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p> <h2 id="_5-总结-3"><a href="#_5-总结-3" class="header-anchor">#</a> 5. 总结</h2> <p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p> <h1 id="第08课-spring-boot中的全局异常处理"><a href="#第08课-spring-boot中的全局异常处理" class="header-anchor">#</a> 第08课：Spring Boot中的全局异常处理</h1> <p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>
针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p> <h2 id="_1-定义返回的统一-json-结构"><a href="#_1-定义返回的统一-json-结构" class="header-anchor">#</a> 1. 定义返回的统一 json 结构</h2> <p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>
这个统一的 json 结构这可以参考[第02课：Spring Boot 返回 JSON 数据及数据封装中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public class JsonResult <span class="token punctuation">{</span>
    /**
     * 异常码
     */
    protected String code<span class="token punctuation">;</span>

    /**
     * 异常信息
     */
    protected String msg<span class="token punctuation">;</span>
	
    public <span class="token function-name function">JsonResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> <span class="token string">&quot;200&quot;</span><span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> <span class="token string">&quot;操作成功&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    public JsonResult<span class="token punctuation">(</span>String code, String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	// get <span class="token builtin class-name">set</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-处理系统异常"><a href="#_2-处理系统异常" class="header-anchor">#</a> 2. 处理系统异常</h2> <p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code>@ControllerAdvice</code> 注解即可拦截项目中抛出的异常，如下：</p> <p>我们点开 <code>@ControllerAdvice</code> 注解可以看到，<code>@ControllerAdvice</code> 注解包含了 <code>@Component</code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code>@ResponseBody</code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@ControllerAdvice</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>
	

    
<span class="token punctuation">}</span>
</code></pre></div><p>在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code>@ExceptionHandler</code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p> <h3 id="_2-1-处理参数缺失异常"><a href="#_2-1-处理参数缺失异常" class="header-anchor">#</a> 2.1 处理参数缺失异常</h3> <p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。</p> <p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
* 缺少请求参数异常
* @param ex MissingServletRequestParameterException
* @return
*/
@ExceptionHandler<span class="token punctuation">(</span>MissingServletRequestParameterException.class<span class="token punctuation">)</span>
@ResponseStatus<span class="token punctuation">(</span>value <span class="token operator">=</span> HttpStatus.BAD_REQUEST<span class="token punctuation">)</span>
public JsonResult handleHttpMessageNotReadableException<span class="token punctuation">(</span>
    MissingServletRequestParameterException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log.error<span class="token punctuation">(</span><span class="token string">&quot;缺少请求参数，{}&quot;</span>, ex.getMessage<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span><span class="token string">&quot;400&quot;</span>, <span class="token string">&quot;缺少必要的请求参数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/exception&quot;</span><span class="token punctuation">)</span>
@Slf4j
public class ExceptionController <span class="token punctuation">{</span>
    

    @PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/test1&quot;</span><span class="token punctuation">)</span>
    public JsonResult test1<span class="token punctuation">(</span>@RequestParam<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> String name,
                            @RequestParam<span class="token punctuation">(</span><span class="token string">&quot;pass&quot;</span><span class="token punctuation">)</span> String pass<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        // 测试参数为空异常
        log.info<span class="token punctuation">(</span><span class="token string">&quot;name：{}&quot;</span>, name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        log.info<span class="token punctuation">(</span><span class="token string">&quot;pass：{}&quot;</span>, pass<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
    
</code></pre></div><p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200926214820048.png" alt="image-20200926214820048"></p> <h3 id="_2-2-处理空指针异常"><a href="#_2-2-处理空指针异常" class="header-anchor">#</a> 2.2 处理空指针异常</h3> <p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>
先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>
还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>
对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code> /**
     * 空指针异常
     * @param ex NullPointerException
     * @return
     */
    @ExceptionHandler<span class="token punctuation">(</span>NullPointerException.class<span class="token punctuation">)</span>
    @ResponseStatus<span class="token punctuation">(</span>value <span class="token operator">=</span> HttpStatus.INTERNAL_SERVER_ERROR<span class="token punctuation">)</span>
    public JsonResult handleTypeMismatchException<span class="token punctuation">(</span>NullPointerException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log.error<span class="token punctuation">(</span><span class="token string">&quot;空指针异常，{}&quot;</span>, ex.getMessage<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span><span class="token string">&quot;500&quot;</span>, <span class="token string">&quot;空指针异常了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;500&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;空指针异常了&quot;</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-3-一劳永逸"><a href="#_2-3-一劳永逸" class="header-anchor">#</a> 2.3 一劳永逸？</h3> <p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p> <div class="language-shell extra-class"><pre class="language-shell"><code> /**
     * 系统异常 预期以外异常
     * @param ex
     * @return
     *
     * 项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，
     * 但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler
     * 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。
     */
    @ExceptionHandler<span class="token punctuation">(</span>Exception.class<span class="token punctuation">)</span>
    @ResponseStatus<span class="token punctuation">(</span>value <span class="token operator">=</span> HttpStatus.INTERNAL_SERVER_ERROR<span class="token punctuation">)</span>
    public JsonResult handleUnexpectedServer<span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger.error<span class="token punctuation">(</span><span class="token string">&quot;系统异常：&quot;</span>, ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span><span class="token string">&quot;500&quot;</span>, <span class="token string">&quot;系统发生异常，请联系管理员&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="_3-拦截自定义异常"><a href="#_3-拦截自定义异常" class="header-anchor">#</a> 3. 拦截自定义异常</h2> <p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很频繁，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p> <h3 id="_3-1-定义异常信息"><a href="#_3-1-定义异常信息" class="header-anchor">#</a> 3.1 定义异常信息</h3> <p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.exception<span class="token punctuation">;</span>
/**
 * 业务异常提示信息枚举类
 */
public enum BusinessMsgEnum <span class="token punctuation">{</span>
    /** 参数异常 */
    PARMETER_EXCEPTION<span class="token punctuation">(</span><span class="token string">&quot;102&quot;</span>, <span class="token string">&quot;参数异常!&quot;</span><span class="token punctuation">)</span>,
    /** 等待超时 */
    SERVICE_TIME_OUT<span class="token punctuation">(</span><span class="token string">&quot;103&quot;</span>, <span class="token string">&quot;服务调用超时！&quot;</span><span class="token punctuation">)</span>,
    /** 参数过大 */
    PARMETER_BIG_EXCEPTION<span class="token punctuation">(</span><span class="token string">&quot;102&quot;</span>, <span class="token string">&quot;输入的图片数量不能超过50张!&quot;</span><span class="token punctuation">)</span>,
    /** <span class="token number">500</span> <span class="token builtin class-name">:</span> 一劳永逸的提示也可以在这定义 */
    UNEXPECTED_EXCEPTION<span class="token punctuation">(</span><span class="token string">&quot;500&quot;</span>, <span class="token string">&quot;系统发生异常，请联系管理员！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    // 还可以定义更多的业务异常
    /**
     * 消息码
     */
    private String code<span class="token punctuation">;</span>
    /**
     * 消息内容
     */
    private String msg<span class="token punctuation">;</span>
    private BusinessMsgEnum<span class="token punctuation">(</span>String code, String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        this.msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  	//  get  <span class="token builtin class-name">set</span>  方法
<span class="token punctuation">}</span>

</code></pre></div><h3 id="_3-2-拦截自定义异常"><a href="#_3-2-拦截自定义异常" class="header-anchor">#</a> 3.2 拦截自定义异常</h3> <p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
 * 自定义业务异常
 *
 */
public class BusinessErrorException extends RuntimeException <span class="token punctuation">{</span>
    
    private static final long serialVersionUID <span class="token operator">=</span> -7480022450501760611L<span class="token punctuation">;</span>

    /**
     * 异常码
     */
    private String code<span class="token punctuation">;</span>
    /**
     * 异常提示信息
     */
    private String message<span class="token punctuation">;</span>

    public BusinessErrorException<span class="token punctuation">(</span>BusinessMsgEnum businessMsgEnum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.code <span class="token operator">=</span> businessMsgEnum.code<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        this.message <span class="token operator">=</span> businessMsgEnum.msg<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	// get set方法
<span class="token punctuation">}</span>
</code></pre></div><p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler <span class="token punctuation">{</span>

    private static final Logger logger <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>GlobalExceptionHandler.class<span class="token punctuation">)</span><span class="token punctuation">;</span>
    /**
     * 拦截业务异常，返回业务异常信息
     * @param ex
     * @return
     */
    @ExceptionHandler<span class="token punctuation">(</span>BusinessErrorException.class<span class="token punctuation">)</span>
    @ResponseStatus<span class="token punctuation">(</span>value <span class="token operator">=</span> HttpStatus.INTERNAL_SERVER_ERROR<span class="token punctuation">)</span>
    public JsonResult handleBusinessError<span class="token punctuation">(</span>BusinessErrorException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String code <span class="token operator">=</span> ex.getCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String message <span class="token operator">=</span> ex.getMessage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token punctuation">(</span>code, message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p> <div class="language- extra-class"><pre class="language-text"><code>@RestController
@RequestMapping(&quot;/exception&quot;)
public class ExceptionController {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);

    @GetMapping(&quot;/business&quot;)
    public JsonResult testException() {
        try {
            int i = 1 / 0;
        } catch (Exception e) {
            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);
        }
        return new JsonResult();
    }
}
</code></pre></div><p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;500&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;系统发生异常，请联系管理员！&quot;</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-总结-4"><a href="#_4-总结-4" class="header-anchor">#</a> 4. 总结</h2> <p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p> <h1 id="第09课-spring-boot中的切面aop处理"><a href="#第09课-spring-boot中的切面aop处理" class="header-anchor">#</a> 第09课：Spring Boot中的切面AOP处理</h1> <h2 id="_1-什么是aop"><a href="#_1-什么是aop" class="header-anchor">#</a> 1. 什么是AOP</h2> <p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？</p> <p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！</p> <p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p> <h2 id="_2-spring-boot-中的-aop-处理"><a href="#_2-spring-boot-中的-aop-处理" class="header-anchor">#</a> 2. Spring Boot 中的 AOP 处理</h2> <h3 id="_2-1-aop-依赖"><a href="#_2-1-aop-依赖" class="header-anchor">#</a> 2.1 AOP 依赖</h3> <p>使用AOP，首先需要引入AOP的依赖。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter-aop<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_2-2-实现-aop-切面"><a href="#_2-2-实现-aop-切面" class="header-anchor">#</a> 2.2 实现 AOP 切面</h3> <p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code>@Aspect</code>注解即可。<code>@Aspect</code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code>@Component</code> 注解让该类交给 Spring 来管理。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Aspect
@Component
public class LogAspectHandler <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这里主要介绍几个常用的注解及使用：</p> <blockquote><p>1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。<br>
2.@Before：在做某件事之前做的事。<br>
3.@After：在做某件事之后做的事。<br>
4.@AfterReturning：在做某件事之后，对其返回值做增强处理。<br>
5.@AfterThrowing：在做某件事抛出异常时，处理。</p> <p>6.@Around</p></blockquote> <h4 id="_2-2-1-pointcut-注解"><a href="#_2-2-1-pointcut-注解" class="header-anchor">#</a> 2.2.1 @Pointcut 注解</h4> <p><code>@Pointcut</code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Aspect
@Component
public class LogAspectHandler <span class="token punctuation">{</span>
 /**
     * 定义一个切面，拦截com.glls.controller包和子包下的所有方法
     */
    @Pointcut<span class="token punctuation">(</span><span class="token string">&quot;execution(* com.glls.springbootdemo1.controller..*.*(..))&quot;</span><span class="token punctuation">)</span>
    public void <span class="token function-name function">pointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    @Pointcut<span class="token punctuation">(</span><span class="token string">&quot;@annotation(org.springframework.web.bind.annotation.GetMapping)&quot;</span><span class="token punctuation">)</span>
    public void <span class="token function-name function">annotationCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p><code>@Pointcut</code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>
以 <code>execution(* com.glls.springbootdemo1.controller..*.*(..)))</code> 表达式为例，语法如下：</p> <blockquote><p><code>execution()</code> 为表达式主体<br>
第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>
包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.glls.springbootdemo1.controller</code> 包、子包下所有类的方法<br>
第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br> <code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p></blockquote> <p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code>@GetMapping</code>注解的方法做切面，可以如下定义切面：</p> <blockquote><p>@Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.GetMapping)&quot;)
public void annotationCut() {}</p></blockquote> <p>然后使用该切面的话，就会切入注解是 <code>@GetMapping</code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@DeleteMapping</code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p> <h4 id="_2-2-2-before-注解"><a href="#_2-2-2-before-注解" class="header-anchor">#</a> 2.2.2 @Before 注解</h4> <p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Aspect
@Component
public class LogAspectHandler <span class="token punctuation">{</span>

    private final Logger logger <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>this.getClass<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>

     /**
     * 在上面定义的切面方法之前执行该方法
     * @param joinPoint jointPoint
     *
     * JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，
     * 包括参数（通过 <span class="token variable"><span class="token variable">`</span>joinPoint.getArgs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token variable">`</span></span> 获取）等等。
     */

    @Before<span class="token punctuation">(</span><span class="token string">&quot;pointCut()&quot;</span><span class="token punctuation">)</span>
    public void doBefore<span class="token punctuation">(</span>JoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;====doBefore方法进入了====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        // 获取签名
        Signature signature <span class="token operator">=</span> joinPoint.getSignature<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 获取切入的包名
        String declaringTypeName <span class="token operator">=</span> signature.getDeclaringTypeName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 获取即将执行的方法名
        String funcName <span class="token operator">=</span> signature.getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;即将执行方法为: {}，属于{}包&quot;</span>, funcName, declaringTypeName<span class="token punctuation">)</span><span class="token punctuation">;</span>

        // 也可以用来记录一些信息，比如获取请求的url和ip
        ServletRequestAttributes attributes <span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder.getRequestAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        HttpServletRequest request <span class="token operator">=</span> attributes.getRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 获取请求url
        String url <span class="token operator">=</span> request.getRequestURL<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 获取请求ip
        String <span class="token function">ip</span> <span class="token operator">=</span> request.getRemoteAddr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;用户请求的url为：{}，ip地址为：{}&quot;</span>, url, <span class="token function">ip</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-2-3-after-注解"><a href="#_2-2-3-after-注解" class="header-anchor">#</a> 2.2.3 @After 注解</h4> <p><code>@After</code> 注解和 <code>@Before</code>  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspectHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">/**
     * 定义一个切面，拦截com.glls.controller包和子包下的所有方法
     */</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* com.glls.springbootdemo1.controller..*.*(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">/**
     * 在上面定义的切面方法之后执行该方法
     * @param joinPoint jointPoint
     */</span>
    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">&quot;pointCut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====doAfter方法进入了====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Signature</span> signature <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;方法{}已经执行完&quot;</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/aop&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/{name}&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">testAop</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p> <div class="language- extra-class"><pre class="language-text"><code>====doBefore方法进入了====  
即将执行方法为: testAop，属于com.glls.springbootdemo1.controller.sec09.AopController包
用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  
====doAfter方法进入了====  
方法testAop已经执行完
</code></pre></div><p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code>@Before</code> 和 <code>@After</code> 两个注解的实际作用。</p> <h4 id="_2-2-4-afterreturning-注解"><a href="#_2-2-4-afterreturning-注解" class="header-anchor">#</a> 2.2.4 @AfterReturning 注解</h4> <p><code>@AfterReturning</code> 注解和 <code>@After</code> 有些类似，区别在于 <code>@AfterReturning</code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspectHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强
     * @param joinPoint joinPoint
     * @param result result
     */</span>
    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">&quot;pointCut()&quot;</span><span class="token punctuation">,</span> returning <span class="token operator">=</span> <span class="token string">&quot;result&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterReturning</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">,</span> <span class="token class-name">Object</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Signature</span> signature <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> classMethod <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;方法{}执行完毕，返回参数为：{}&quot;</span><span class="token punctuation">,</span> classMethod<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 实际项目中可以根据业务做具体的返回值增强</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;对返回参数进行业务上的增强：{}&quot;</span><span class="token punctuation">,</span> result <span class="token operator">+</span> <span class="token string">&quot;增强版&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意的是：在 <code>@AfterReturning</code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>方法testAop执行完毕，返回参数为：Hello CSDN  
对返回参数进行业务上的增强：Hello CSDN增强版
</code></pre></div><h4 id="_2-2-5-afterthrowing-注解"><a href="#_2-2-5-afterthrowing-注解" class="header-anchor">#</a> 2.2.5 @AfterThrowing 注解</h4> <p>顾名思义，<code>@AfterThrowing</code> 注解是当被切方法执行时抛出异常时，会进入 <code>@AfterThrowing</code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
 * 使用AOP处理log
 */
@Aspect
@Component
public class LogAspectHandler <span class="token punctuation">{</span>

    private final Logger logger <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>this.getClass<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>

    /**
     * 在上面定义的切面方法执行抛异常时，执行该方法
     * @param joinPoint jointPoint
     * @param ex ex
     */
    @AfterThrowing<span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">&quot;pointCut()&quot;</span>, throwing <span class="token operator">=</span> <span class="token string">&quot;ex&quot;</span><span class="token punctuation">)</span>
    public void afterThrowing<span class="token punctuation">(</span>JoinPoint joinPoint, Throwable ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Signature signature <span class="token operator">=</span> joinPoint.getSignature<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String method <span class="token operator">=</span> signature.getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 处理异常的逻辑
        logger.info<span class="token punctuation">(</span><span class="token string">&quot;执行方法{}出错，异常为：{}&quot;</span>, method, ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#测试</span>
   @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/exec&quot;</span><span class="token punctuation">)</span>
    public String <span class="token function-name function">testAop2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int a <span class="token operator">=</span> <span class="token number">5</span>/0<span class="token punctuation">;</span>

        <span class="token builtin class-name">return</span> <span class="token string">&quot;Hello &quot;</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

抛出异常    afterThrowing  会执行
执行方法testAop2出错，异常为：<span class="token punctuation">{</span><span class="token punctuation">}</span>
java.lang.ArithmeticException: / by zero
    
</code></pre></div><h4 id="_2-2-6-around-注解"><a href="#_2-2-6-around-注解" class="header-anchor">#</a> 2.2.6 @Around 注解</h4> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;pointCut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span>  <span class="token function">around</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//获取方法的参数值数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;修改之前的请求参数为{}&quot;</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 得到其方法签名</span>
        <span class="token class-name">MethodSignature</span> signature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodSignature</span><span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获取方法的参数类型数组</span>
        <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">[</span>parameterTypes<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">&quot;xxx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;xxx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            args<span class="token punctuation">[</span>args<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> user<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;修改之后的请求参数{}&quot;</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;环绕前置通知&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">//目标方法执行</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>


            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;相应结果是{}&quot;</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;环绕返回通知&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;环绕异常通知&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;环绕最终通知&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">&quot;幕后黑手&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;8888&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果这里返回null   则目标对象实际返回值也会被置为null</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>controller 方法</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/test2&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">testAop2</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行到了controller的test2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>执行顺序：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210517151059876.png" alt="image-20210517151059876"></p> <p>页面响应：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210517151125950.png" alt="image-20210517151125950"></p> <h2 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> 3. 总结</h2> <p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p> <p>补充： 至于 aop 的执行顺序 这个不用刻意记忆    工作当中 直接看代码直接结果即可  ，大致执行顺序得知道<a href="https://www.cnblogs.com/orzjiangxiaoyu/p/13869747.html" target="_blank" rel="noopener noreferrer">Spring-AOP-基于注解的AOP通知执行顺序 - orz江小鱼 - 博客园 (cnblogs.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>    参考这个博客  理解即可</p> <p>补充： 对于@Around 这个特殊一点的通知  参考理解 <a href="https://blog.csdn.net/qq_41981107/article/details/85260765" target="_blank" rel="noopener noreferrer">(20条消息) @Around简单使用示例——SpringAOP增强处理_咚咚大帝的博客-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>自定义注解 作为 切点</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210515180418585.png" alt="image-20210515180418585"></p> <h1 id="第10课-spring-boot集成mybatis"><a href="#第10课-spring-boot集成mybatis" class="header-anchor">#</a> 第10课：Spring Boot集成MyBatis</h1> <h2 id="_1-mybatis-介绍"><a href="#_1-mybatis-介绍" class="header-anchor">#</a> 1. MyBatis 介绍</h2> <p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p> <h2 id="_2-mybatis-的配置"><a href="#_2-mybatis-的配置" class="header-anchor">#</a> 2. MyBatis 的配置</h2> <h2 id="_2-1-依赖导入"><a href="#_2-1-依赖导入" class="header-anchor">#</a> 2.1 依赖导入</h2> <p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>  <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.mybatis.spring.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-spring-boot-starter<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">1.3</span>.<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/version<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>mysql<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mysql-connector-java<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span><span class="token operator">!</span>-- 省去其他 --<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.mybatis<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.mybatis<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-spring<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h2 id="_2-2-配置文件"><a href="#_2-2-配置文件" class="header-anchor">#</a> 2.2 配置文件</h2> <p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p> <div class="language-shell extra-class"><pre class="language-shell"><code>spring:
  profiles:
    active: dev


  datasource: <span class="token comment"># 数据库配置</span>
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ssm?characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span><span class="token assign-left variable">useSSL</span><span class="token operator">=</span>false<span class="token operator">&amp;</span><span class="token assign-left variable">serverTimezone</span><span class="token operator">=</span>Asia/Shanghai<span class="token operator">&amp;</span><span class="token assign-left variable">rewriteBatchedStatements</span><span class="token operator">=</span>true
    username: root
    password: <span class="token number">123456</span>
    hikari:
      maximum-pool-size: <span class="token number">10</span> <span class="token comment"># 最大连接池数</span>
      max-lifetime: <span class="token number">1770000</span>

mybatis:
  <span class="token comment"># 指定别名设置的包为所有entity</span>
  type-aliases-package: com.glls.springbootdemo1.pojo
  configuration:
    map-underscore-to-camel-case: <span class="token boolean">true</span> <span class="token comment"># 驼峰命名规范</span>
  mapper-locations: classpath:mapper/*.xml    <span class="token comment"># mapper映射文件位置</span>
  
</code></pre></div><p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的弟弟可以去百度或者谷歌搜一搜，了解一下。</p> <p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p> <h2 id="_3-基于-xml-的整合"><a href="#_3-基于-xml-的整合" class="header-anchor">#</a> 3. 基于 xml 的整合</h2> <p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">&quot;1.0&quot;</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span><span class="token string">&quot;UTF-8&quot;</span>?<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE mapper PUBLIC <span class="token string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="token string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>mapper <span class="token assign-left variable">namespace</span><span class="token operator">=</span><span class="token string">&quot;com.glls.springbootdemo1.mapper.UserMapper&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>resultMap <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">&quot;BaseResultMap&quot;</span> <span class="token assign-left variable">type</span><span class="token operator">=</span><span class="token string">&quot;com.glls.springbootdemo1.pojo.User&quot;</span><span class="token operator">&gt;</span>

        <span class="token operator">&lt;</span>id <span class="token assign-left variable">column</span><span class="token operator">=</span><span class="token string">&quot;id&quot;</span> <span class="token assign-left variable">jdbcType</span><span class="token operator">=</span><span class="token string">&quot;BIGINT&quot;</span> <span class="token assign-left variable">property</span><span class="token operator">=</span><span class="token string">&quot;id&quot;</span> /<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>result <span class="token assign-left variable">column</span><span class="token operator">=</span><span class="token string">&quot;username&quot;</span> <span class="token assign-left variable">jdbcType</span><span class="token operator">=</span><span class="token string">&quot;VARCHAR&quot;</span> <span class="token assign-left variable">property</span><span class="token operator">=</span><span class="token string">&quot;username&quot;</span> /<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>result <span class="token assign-left variable">column</span><span class="token operator">=</span><span class="token string">&quot;password&quot;</span> <span class="token assign-left variable">jdbcType</span><span class="token operator">=</span><span class="token string">&quot;VARCHAR&quot;</span> <span class="token assign-left variable">property</span><span class="token operator">=</span><span class="token string">&quot;password&quot;</span> /<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/resultMap<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>select <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">&quot;getUserByName&quot;</span> <span class="token assign-left variable">resultType</span><span class="token operator">=</span><span class="token string">&quot;com.glls.springbootdemo1.pojo.User&quot;</span> <span class="token assign-left variable">parameterType</span><span class="token operator">=</span><span class="token string">&quot;String&quot;</span><span class="token operator">&gt;</span>
       <span class="token keyword">select</span> * from t_user where username <span class="token operator">=</span> <span class="token comment">#{username}</span>
    <span class="token operator">&lt;</span>/select<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>select <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">&quot;findUsers&quot;</span> <span class="token assign-left variable">resultType</span><span class="token operator">=</span><span class="token string">&quot;com.glls.springbootdemo1.pojo.User&quot;</span><span class="token operator">&gt;</span>
        <span class="token keyword">select</span> * from t_user
    <span class="token operator">&lt;</span>/select<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>/mapper<span class="token operator">&gt;</span>
</code></pre></div><p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。</p> <p>实体类中有 id，username 和 password。UserMapper.java 文件中写一个接口即可：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>User getUserByName<span class="token punctuation">(</span>String username<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.controller.sec10<span class="token punctuation">;</span>


<span class="token function">import</span> com.glls.springbootdemo1.common.JsonResult<span class="token punctuation">;</span>
<span class="token function">import</span> com.glls.springbootdemo1.pojo.User<span class="token punctuation">;</span>
<span class="token function">import</span> com.glls.springbootdemo1.service.UserService<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.web.bind.annotation.*<span class="token punctuation">;</span>

<span class="token function">import</span> javax.annotation.Resource<span class="token punctuation">;</span>


@RestController
@RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/mybatis&quot;</span><span class="token punctuation">)</span>
public class MybatisController <span class="token punctuation">{</span>

    @Resource
    private UserService userService<span class="token punctuation">;</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/findUser/{name}&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> getUserByName<span class="token punctuation">(</span>@PathVariable<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> String username<span class="token punctuation">)</span><span class="token punctuation">{</span>
        User user <span class="token operator">=</span> userService.findUserByName<span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/findUserById/{id}&quot;</span><span class="token punctuation">)</span>
    public JsonResult<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> getUserById<span class="token punctuation">(</span>@PathVariable<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> Long <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        User user <span class="token operator">=</span> userService.findUserById<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token builtin class-name">return</span> new JsonResult<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    
    @PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/adduser&quot;</span><span class="token punctuation">)</span>
    public String addUser<span class="token punctuation">(</span>@RequestBody User user<span class="token punctuation">)</span> throws Exception <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            userService.isertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token builtin class-name">return</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

</code></pre></div><p>启动项目，在浏览器中输入：<code>http://localhost:8080/mybatis/findUser/abc</code> 即可查询到数据库表中用户名为 abc 的用户信息（事先搞两个数据进去即可）：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token string">&quot;data&quot;</span>:<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;abc&quot;</span>,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;111&quot;</span><span class="token punctuation">}</span>,<span class="token string">&quot;code&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;0&quot;</span>,<span class="token string">&quot;msg&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code>@Mapper</code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code>@Mapper</code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code>@MaperScan</code> 注解，来扫描一个包下的所有 mapper。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@SpringBootApplication
@MapperScan<span class="token punctuation">(</span><span class="token string">&quot;com.glls.springbootdemo1.mapper&quot;</span><span class="token punctuation">)</span>
public class SpringbootDemo1Application <span class="token punctuation">{</span>

    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SpringApplication.run<span class="token punctuation">(</span>SpringbootDemo1Application.class, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这样的话，<code>com.glls.springbootdemo1.mapper</code> 包下的所有 mapper 都会被扫描到了。</p> <h2 id="_4-基于注解的整合"><a href="#_4-基于注解的整合" class="header-anchor">#</a> 4. 基于注解的整合</h2> <p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code>@Select</code>， <code>@Insert</code>， <code>@Update</code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Select<span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id}&quot;</span><span class="token punctuation">)</span>
User getUser<span class="token punctuation">(</span>Long <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code>@Param</code> 注解来指定每一个参数的对应关系，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Select<span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id} and user_name=#{name}&quot;</span><span class="token punctuation">)</span>
User getUserByIdAndName<span class="token punctuation">(</span>@Param<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> Long id, @Param<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> String username<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看出，<code>@Param</code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下</p> <p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code>@Results</code> 注解来解决。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Select<span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id}&quot;</span><span class="token punctuation">)</span>
@Results<span class="token punctuation">(</span><span class="token punctuation">{</span>
        @Result<span class="token punctuation">(</span>property <span class="token operator">=</span> <span class="token string">&quot;username&quot;</span>, <span class="token function">column</span> <span class="token operator">=</span> <span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span>,
        @Result<span class="token punctuation">(</span>property <span class="token operator">=</span> <span class="token string">&quot;password&quot;</span>, <span class="token function">column</span> <span class="token operator">=</span> <span class="token string">&quot;password&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
User getUser<span class="token punctuation">(</span>Long <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>@Results</code> 中的 <code>@Result</code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。</p> <p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code>@ResultMap</code> 注解来替代 <code>@Results</code> 注解，如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Select<span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id}&quot;</span><span class="token punctuation">)</span>
@ResultMap<span class="token punctuation">(</span><span class="token string">&quot;BaseResultMap&quot;</span><span class="token punctuation">)</span>
User getUser<span class="token punctuation">(</span>Long <span class="token function">id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>@ResultMap</code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p> <div class="language-she extra-class"><pre class="language-text"><code>&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.glls.springbootdemo1.pojo.User&quot;&gt;
</code></pre></div><p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p> <h2 id="_5-总结-4"><a href="#_5-总结-4" class="header-anchor">#</a> 5. 总结</h2> <p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p> <h1 id="第11课-spring-boot事务配置管理"><a href="#第11课-spring-boot事务配置管理" class="header-anchor">#</a> 第11课：Spring Boot事务配置管理</h1> <h2 id="_1-事务相关"><a href="#_1-事务相关" class="header-anchor">#</a> 1. 事务相关</h2> <p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。</p> <p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p> <p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p> <h2 id="_2-spring-boot-事务配置"><a href="#_2-spring-boot-事务配置" class="header-anchor">#</a> 2. Spring Boot 事务配置</h2> <h3 id="_2-1-依赖导入-2"><a href="#_2-1-依赖导入-2" class="header-anchor">#</a> 2.1 依赖导入</h3> <p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>mysql<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mysql-connector-java<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code>@Transactional</code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。</p> <h3 id="_2-2-事务的测试"><a href="#_2-2-事务的测试" class="header-anchor">#</a> 2.2 事务的测试</h3> <p>我们首先在数据库表中插入一条数据：</p> <table><thead><tr><th style="text-align:center;">id</th> <th style="text-align:center;">user_name</th> <th style="text-align:center;">password</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">zs</td> <td style="text-align:center;">123456</td></tr></tbody></table> <p>然后我们写一个插入的 mapper：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>public interface UserMapper <span class="token punctuation">{</span>

    @Insert<span class="token punctuation">(</span><span class="token string">&quot;insert into user (user_name, password) values (#{username}, #{password})&quot;</span><span class="token punctuation">)</span>
    Integer insertUser<span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Service
public class UserServiceImpl implements UserService <span class="token punctuation">{</span>

    @Resource
    private UserMapper userMapper<span class="token punctuation">;</span>

    @Override
    @Transactional
    public void isertUser<span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 插入用户信息
        userMapper.insertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 手动抛出异常
        throw new RuntimeException<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们来测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code> @PostMapping<span class="token punctuation">(</span><span class="token string">&quot;/adduser&quot;</span><span class="token punctuation">)</span>
    public String addUser<span class="token punctuation">(</span>@RequestBody User user<span class="token punctuation">)</span> throws Exception <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            userService.isertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token builtin class-name">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token builtin class-name">return</span> <span class="token string">&quot;false&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p> <h2 id="_3-常见问题总结"><a href="#_3-常见问题总结" class="header-anchor">#</a> 3. 常见问题总结</h2> <p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code>@Transactional</code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。</p> <p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p> <h3 id="_3-1-异常并没有被-捕获-到"><a href="#_3-1-异常并没有被-捕获-到" class="header-anchor">#</a> 3.1 异常并没有被 ”捕获“ 到</h3> <p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Service
public class UserServiceImpl implements UserService <span class="token punctuation">{</span>

    @Resource
    private UserMapper userMapper<span class="token punctuation">;</span>
    
    @Override
    @Transactional
    public void isertUser2<span class="token punctuation">(</span>User user<span class="token punctuation">)</span> throws Exception <span class="token punctuation">{</span>
        // 插入用户信息
        userMapper.insertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        // 手动抛出异常
        throw new SQLException<span class="token punctuation">(</span><span class="token string">&quot;数据库异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。</p> <p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code>@Transactional</code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code>@Transactional(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p> <h3 id="_3-2-异常被-吃-掉"><a href="#_3-2-异常被-吃-掉" class="header-anchor">#</a> 3.2 异常被 ”吃“ 掉</h3> <p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try...catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Service
public class UserServiceImpl implements UserService <span class="token punctuation">{</span>

    @Resource
    private UserMapper userMapper<span class="token punctuation">;</span>

    @Override
    @Transactional<span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception.class<span class="token punctuation">)</span>
    public void isertUser3<span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        try <span class="token punctuation">{</span>
            // 插入用户信息
            userMapper.insertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            // 手动抛出异常
            throw new SQLException<span class="token punctuation">(</span><span class="token string">&quot;数据库异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			// 异常处理逻辑
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try...catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。</p> <p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p> <h3 id="_3-3-事务的范围"><a href="#_3-3-事务的范围" class="header-anchor">#</a> 3.3 事务的范围</h3> <p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。</p> <p>我来写个 demo：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Service
public class UserServiceImpl implements UserService <span class="token punctuation">{</span>

    @Resource
    private UserMapper userMapper<span class="token punctuation">;</span>

    @Override
    @Transactional<span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception.class<span class="token punctuation">)</span>
    public synchronized void isertUser4<span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        // 实际中的具体业务……
        userMapper.insertUser<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。</p> <p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。</p> <p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。</p> <p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p> <h2 id="_4-总结-5"><a href="#_4-总结-5" class="header-anchor">#</a> 4. 总结</h2> <p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code>@Transactional</code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的弟弟。</p> <h1 id="第12课-spring-boot中使用监听器"><a href="#第12课-spring-boot中使用监听器" class="header-anchor">#</a> 第12课：Spring Boot中使用监听器</h1> <h2 id="_1-监听器介绍"><a href="#_1-监听器介绍" class="header-anchor">#</a> 1. 监听器介绍</h2> <p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p> <h2 id="_2-spring-boot中监听器的使用"><a href="#_2-spring-boot中监听器的使用" class="header-anchor">#</a> 2. Spring Boot中监听器的使用</h2> <p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p> <h3 id="_2-1-监听servlet上下文对象"><a href="#_2-1-监听servlet上下文对象" class="header-anchor">#</a> 2.1 监听Servlet上下文对象</h3> <p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。</p> <p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p> <p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 获取用户信息
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实际中会根据具体的业务场景，从数据库中查询对应的信息</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 使用ApplicationListener来初始化一些数据到application域中的监听器

 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServletContextListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ContextRefreshedEvent</span> contextRefreshedEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先获取到application上下文</span>
        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> contextRefreshedEvent<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取对应的service</span>
        <span class="token class-name">UserService</span> userService <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取application域对象，将查到的信息放到application域中</span>
        <span class="token class-name">ServletContext</span> application <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">ServletContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        application<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/listener&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ServletContext</span> application <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> application<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p> <h3 id="_2-2-监听http会话-session对象"><a href="#_2-2-监听http会话-session对象" class="header-anchor">#</a> 2.2 监听HTTP会话 Session对象</h3> <p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 使用HttpSessionListener统计在线用户数的监听器
 * @author  glls
 * @date 2018/07/05
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyHttpSessionListener</span> <span class="token keyword">implements</span> <span class="token class-name">HttpSessionListener</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">MyHttpSessionListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 记录在线的用户数量
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sessionCreated</span><span class="token punctuation">(</span><span class="token class-name">HttpSessionEvent</span> httpSessionEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;新用户上线了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        httpSessionEvent<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;count&quot;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sessionDestroyed</span><span class="token punctuation">(</span><span class="token class-name">HttpSessionEvent</span> httpSessionEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;用户下线了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        httpSessionEvent<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;count&quot;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/listener&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 获取当前在线人数，该方法有bug
     * @param request
     * @return
     */</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/total&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getTotalUser</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;count&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;当前在线人数：&quot;</span> <span class="token operator">+</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/total2&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getTotalUser</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Cookie</span> cookie<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把sessionId记录在浏览器中</span>
        cookie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span><span class="token string">&quot;JSESSIONID&quot;</span><span class="token punctuation">,</span> <span class="token class-name">URLEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cookie<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//设置cookie有效期为2天，设置长一点</span>
        cookie<span class="token punctuation">.</span><span class="token function">setMaxAge</span><span class="token punctuation">(</span> <span class="token number">48</span><span class="token operator">*</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;count&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;当前在线人数：&quot;</span> <span class="token operator">+</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p> <h3 id="_2-3-监听客户端请求servlet-request对象"><a href="#_2-3-监听客户端请求servlet-request对象" class="header-anchor">#</a> 2.3 监听客户端请求Servlet Request对象</h3> <p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 使用ServletRequestListener获取访问信息
 * @author  glls
 * @date 2018/07/05
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyServletRequestListener</span> <span class="token keyword">implements</span> <span class="token class-name">ServletRequestListener</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">MyServletRequestListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestInitialized</span><span class="token punctuation">(</span><span class="token class-name">ServletRequestEvent</span> servletRequestEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">)</span> servletRequestEvent<span class="token punctuation">.</span><span class="token function">getServletRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;session id为：{}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestedSessionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;request url为：{}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestDestroyed</span><span class="token punctuation">(</span><span class="token class-name">ServletRequestEvent</span> servletRequestEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;request end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">)</span> servletRequestEvent<span class="token punctuation">.</span><span class="token function">getServletRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;request域中保存的name值为：{}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/request&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getRequestInfo</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;requestListener中的初始化的name数据：&quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-spring-boot中自定义事件监听"><a href="#_3-spring-boot中自定义事件监听" class="header-anchor">#</a> 3. Spring Boot中自定义事件监听</h2> <p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p> <h3 id="_3-1-自定义事件"><a href="#_3-1-自定义事件" class="header-anchor">#</a> 3.1 自定义事件</h3> <p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 自定义事件
 * @author  glls
 * @date 2018/07/05
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省去get、set方法</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-2-自定义监听器"><a href="#_3-2-自定义监听器" class="header-anchor">#</a> 3.2 自定义监听器</h3> <p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 自定义监听器，监听MyEvent事件
 * @author  glls
 * @date 2018/07/05
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyEventListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">MyEvent</span> myEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把事件中的信息获取到</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> myEvent<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;用户名：&quot;</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;密码：&quot;</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p> <p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * UserService
 * @author  glls
 */</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 发布事件
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 发布事件</span>
        <span class="token class-name">MyEvent</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p> <p>最后，在 Controller 中写一个接口来测试一下：</p> <p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p> <h2 id="_4-总结-6"><a href="#_4-总结-6" class="header-anchor">#</a> 4. 总结</h2> <p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望认真消化。</p> <h1 id="第13课-spring-boot中使用拦截器"><a href="#第13课-spring-boot中使用拦截器" class="header-anchor">#</a> 第13课：Spring Boot中使用拦截器</h1> <p>面试题：拦截器和过滤器的区别 ？？？？？？？</p> <p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p> <h2 id="_1-拦截器的快速使用"><a href="#_1-拦截器的快速使用" class="header-anchor">#</a> 1. 拦截器的快速使用</h2> <p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p> <h3 id="_1-1-定义拦截器"><a href="#_1-1-定义拦截器" class="header-anchor">#</a> 1.1 定义拦截器</h3> <p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p> <blockquote><p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br> <code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br> <code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。</p></blockquote> <p>了解了该接口，接下来自定义一个拦截器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 自定义拦截器
 * @author 
 * @date
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">MyInterceptor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">HandlerMethod</span> handlerMethod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HandlerMethod</span><span class="token punctuation">)</span> handler<span class="token punctuation">;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> handlerMethod<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;</span><span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回true才会继续执行，返回false则取消当前请求</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">ModelAndView</span> modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p> <h3 id="_1-2-配置拦截器"><a href="#_1-2-配置拦截器" class="header-anchor">#</a> 1.2 配置拦截器</h3> <p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptorConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addInterceptors</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/interceptor&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span>拦截到了方法：test，在该方法执行之前执行<span class="token operator">==</span><span class="token operator">==</span>  
执行完方法之后进执行<span class="token punctuation">(</span>Controller方法调用之后<span class="token punctuation">)</span>，但是此时还没进行视图渲染  
整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了
</code></pre></div><p>可以看出拦截器已经生效，并能看出其执行顺序。</p> <h3 id="_1-3-解决静态资源被拦截问题"><a href="#_1-3-解决静态资源被拦截问题" class="header-anchor">#</a> 1.3 解决静态资源被拦截问题</h3> <p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p> <p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p> <p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
 * @param registry
 */</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span><span class="token class-name">ResourceHandlerRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:/static/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p> <p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptorConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p> <p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p> <h2 id="_2-拦截器使用实例"><a href="#_2-拦截器使用实例" class="header-anchor">#</a> 2. 拦截器使用实例</h2> <h3 id="_2-1-判断用户有没有登录"><a href="#_2-1-判断用户有没有登录" class="header-anchor">#</a> 2.1 判断用户有没有登录</h3> <p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

    <span class="token class-name">HandlerMethod</span> handlerMethod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HandlerMethod</span><span class="token punctuation">)</span> handler<span class="token punctuation">;</span>
    <span class="token class-name">Method</span> method <span class="token operator">=</span> handlerMethod<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;</span><span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token</span>
    <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> token <span class="token operator">||</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;用户未登录，没有权限执行……请登录&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回true才会继续执行，返回false则取消当前请求</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p> <h3 id="_2-2-取消拦截操作"><a href="#_2-2-取消拦截操作" class="header-anchor">#</a> 2.2 取消拦截操作</h3> <p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p> <p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 该注解用来指定某个方法不用拦截
 */</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">UnInterception</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

    <span class="token class-name">HandlerMethod</span> handlerMethod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HandlerMethod</span><span class="token punctuation">)</span> handler<span class="token punctuation">;</span>
    <span class="token class-name">Method</span> method <span class="token operator">=</span> handlerMethod<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;</span><span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截</span>
    <span class="token comment">// @UnInterception 是我们自定义的注解</span>
    <span class="token class-name">UnInterception</span> unInterception <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">UnInterception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> unInterception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回true才会继续执行，返回false则取消当前请求</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p> <h2 id="_3-总结-2"><a href="#_3-总结-2" class="header-anchor">#</a> 3. 总结</h2> <p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p> <h1 id="第14课-spring-boot-中集成redis"><a href="#第14课-spring-boot-中集成redis" class="header-anchor">#</a> 第14课：Spring Boot 中集成Redis</h1> <h2 id="_1-redis-介绍"><a href="#_1-redis-介绍" class="header-anchor">#</a> 1. Redis 介绍</h2> <p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。
NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。
Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906111156947.png" alt="image-20200906111156947"></p> <p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p> <h2 id="_2-redis-安装"><a href="#_2-redis-安装" class="header-anchor">#</a> 2.Redis 安装</h2> <div class="language-shell extra-class"><pre class="language-shell"><code>使用docker 安装  
</code></pre></div><h2 id="_3-spring-boot-集成-redis"><a href="#_3-spring-boot-集成-redis" class="header-anchor">#</a> 3. Spring Boot 集成 Redis</h2> <h3 id="_3-1-依赖导入"><a href="#_3-1-依赖导入" class="header-anchor">#</a> 3.1 依赖导入</h3> <p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter-data-redis<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>--阿里巴巴fastjson --<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.alibaba<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>fastjson<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">1.2</span>.3<span class="token operator"><span class="token file-descriptor important">5</span>&lt;</span>/version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p> <h3 id="_3-2-redis-配置"><a href="#_3-2-redis-配置" class="header-anchor">#</a> 3.2 Redis 配置</h3> <p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>server:
  port: <span class="token number">8080</span>
spring:
  <span class="token comment">#redis相关配置</span>
  redis:
    <span class="token comment"># 配置redis的主机地址，需要修改成自己的</span>
    host: <span class="token number">192.168</span>.153.102
    port: <span class="token number">6379</span>
    password: 
    timeout: <span class="token number">5000</span>
    jedis:
      pool:
        <span class="token comment"># 连接池中的最大空闲连接，默认值也是8。</span>
        max-idle: <span class="token number">500</span>
        <span class="token comment"># 连接池中的最小空闲连接，默认值也是0。</span>
        min-idle: <span class="token number">50</span>
        <span class="token comment"># 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)</span>
        max-active: <span class="token number">1000</span>
        <span class="token comment"># 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException</span>
        max-wait: <span class="token number">2000</span>
</code></pre></div><h3 id="_3-3-常用-api-介绍"><a href="#_3-3-常用-api-介绍" class="header-anchor">#</a> 3.3 常用 api 介绍</h3> <p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p> <p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p> <h4 id="_3-3-1-redis-string-类型"><a href="#_3-3-1-redis-string-类型" class="header-anchor">#</a> 3.3.1 redis:string 类型</h4> <p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Component
public class RedisService <span class="token punctuation">{</span>

    @Resource
    private StringRedisTemplate stringRedisTemplate<span class="token punctuation">;</span>

    /**
     * <span class="token builtin class-name">set</span> redis: string类型
     * @param key key
     * @param value value
     */
    public void setString<span class="token punctuation">(</span>String key, String value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ValueOperations<span class="token operator">&lt;</span>String, String<span class="token operator">&gt;</span> valueOperations <span class="token operator">=</span> stringRedisTemplate.opsForValue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        valueOperations.set<span class="token punctuation">(</span>key, value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    /**
     * get redis: string类型
     * @param key key
     * @return
     */
    public String getString<span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token builtin class-name">return</span> stringRedisTemplate.opsForValue<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Autowired
    private UserService userService<span class="token punctuation">;</span>
    @Autowired
    private RedisService redisService<span class="token punctuation">;</span>

    @RequestMapping<span class="token punctuation">(</span><span class="token string">&quot;/addUser&quot;</span><span class="token punctuation">)</span>
    public User <span class="token function-name function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        // 如果是个实体，我们可以使用json工具转成json字符串，
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span>1l,<span class="token string">&quot;zs&quot;</span>, <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        /**
         * fastjson <span class="token parameter variable">--JSON</span> 用法
         *
         * 对象  转json字符串      JSON.toJSONString<span class="token punctuation">(</span>user<span class="token punctuation">)</span>
         * 字符串转对象     User user1 <span class="token operator">=</span> JSON.parseObject<span class="token punctuation">(</span>userInfo, User.class<span class="token punctuation">)</span><span class="token punctuation">;</span>
         * */

        redisService.setString<span class="token punctuation">(</span><span class="token string">&quot;userInfo&quot;</span>, JSON.toJSONString<span class="token punctuation">(</span>user<span class="token punctuation">))</span><span class="token punctuation">;</span>
        log.info<span class="token punctuation">(</span><span class="token string">&quot;用户信息：{}&quot;</span>, redisService.getString<span class="token punctuation">(</span><span class="token string">&quot;userInfo&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>

        String userInfo <span class="token operator">=</span> redisService.getString<span class="token punctuation">(</span><span class="token string">&quot;userInfo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        User user1 <span class="token operator">=</span> JSON.parseObject<span class="token punctuation">(</span>userInfo, User.class<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token builtin class-name">return</span> user1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>用户信息：<span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span>:1,<span class="token string">&quot;password&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;123456&quot;</span>,<span class="token string">&quot;username&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;zs&quot;</span><span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-3-2-redis-hash-类型"><a href="#_3-3-2-redis-hash-类型" class="header-anchor">#</a> 3.3.2 redis:hash 类型</h4> <p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.springbootdemo1.redis<span class="token punctuation">;</span>

<span class="token function">import</span> org.springframework.data.redis.core.HashOperations<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.data.redis.core.ListOperations<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.data.redis.core.StringRedisTemplate<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.data.redis.core.ValueOperations<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.stereotype.Component<span class="token punctuation">;</span>

<span class="token function">import</span> javax.annotation.Resource<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.List<span class="token punctuation">;</span>

@Component
public class RedisService <span class="token punctuation">{</span>

    @Resource
    private StringRedisTemplate stringRedisTemplate<span class="token punctuation">;</span>

    /**
     * <span class="token builtin class-name">set</span> redis: hash类型
     * @param key key
     * @param filedKey filedkey
     * @param value value
     */
    public void setHash<span class="token punctuation">(</span>String key, String filedKey, String value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        HashOperations<span class="token operator">&lt;</span>String, Object, Object<span class="token operator">&gt;</span> hashOperations <span class="token operator">=</span> stringRedisTemplate.opsForHash<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashOperations.put<span class="token punctuation">(</span>key,filedKey, value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    /**
     * get redis: hash类型
     * @param key key
     * @param filedkey filedkey
     * @return
     */
    public String getHash<span class="token punctuation">(</span>String key, String filedkey<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token builtin class-name">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> stringRedisTemplate.opsForHash<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span>key, filedkey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    
<span class="token punctuation">}</span>

</code></pre></div><p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code> //测试redis的hash类型
        redisService.setHash<span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span>, <span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;zs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log.info<span class="token punctuation">(</span><span class="token string">&quot;用户姓名：{}&quot;</span>, redisService.getHash<span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span>,<span class="token string">&quot;name&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_3-3-3-redis-list-类型"><a href="#_3-3-3-redis-list-类型" class="header-anchor">#</a> 3.3.3 redis:list 类型</h4> <p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code>  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
     * set redis:list类型
     * @param key key
     * @param value value
     * @return
     */
    public long setList(String key, String value){
        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();

        return listOperations.leftPush(key, value);
    }

    /**
     * get redis:list类型
     * @param key key
     * @param start start
     * @param end end
     * @return
     */
    public List&lt;String&gt; getList(String key, long start, long end){
        return stringRedisTemplate.opsForList().range(key, start, end);
    }
</code></pre></div><p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code> //测试redis的list类型
        redisService.setList<span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span>, <span class="token string">&quot;football&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisService.setList<span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span>, <span class="token string">&quot;basketball&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> valList <span class="token operator">=</span> redisService.getList<span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span>,0,-1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        for<span class="token punctuation">(</span>String value :valList<span class="token punctuation">)</span><span class="token punctuation">{</span>
            logger.info<span class="token punctuation">(</span><span class="token string">&quot;list中有：{}&quot;</span>, value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-redistemplate-和-stringredistemplate"><a href="#_4-redistemplate-和-stringredistemplate" class="header-anchor">#</a> 4.redisTemplate 和 stringRedisTemplate</h2> <p>区别如下:</p> <h4 id="_4-1-两者关系是stringredistemplate继承redistemplate。"><a href="#_4-1-两者关系是stringredistemplate继承redistemplate。" class="header-anchor">#</a> 4.1.两者关系是StringRedisTemplate继承RedisTemplate。</h4> <blockquote><p>从StringRedisTemplate源码即可看出，如下图所示:</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906124209247.png" alt="image-20200906124209247"></p></blockquote> <blockquote><p>2.两者的数据是不共通的，也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。</p></blockquote> <blockquote><p>3.使用的序列化类不同。
使用的序列化哪里不同?如下所示:
(1)RedisTemplate使用的是JdkSerializationRedisSerializer 存入数据会将数据先序列化成字节组然后再存入Redis数据库。
(2)StringRedisTemplate使用的是StringRedisSerializer。</p></blockquote> <blockquote><p>使用时注意事项:
(1)当你的Redis数据库里面本来存的是字符串数据或者是你要存取的数据就是字符串类型数据的时候，那么你就使用StringRedisTemplate即可;
(2)但是如果你的数据是复杂的对象类型，而取出的时候又不想做任何数据转换，直接从Redis里面取出一个对象，那么使用RedisTemplate是更好的选择;
(3)RedisTemplate中存取数据都是字节数组。当Redis存入的数据是可读形式而非字节数组时，使用RedisTemplate取值的时候会无法获取导出数据，获得的值为null。可以使用StringRedisTemplate试试;</p></blockquote> <h4 id="_4-2redistemplate定义了5种数据结构操作"><a href="#_4-2redistemplate定义了5种数据结构操作" class="header-anchor">#</a> 4.2RedisTemplate定义了5种数据结构操作</h4> <blockquote><p>redisTemplate.opsForValue();//操作字符串
redisTemplate.opsForHash();//操作hash
redisTemplate.opsForList();//操作list
redisTemplate.opsForSet();//操作set
redisTemplate.opsForZSet();//操作有序set</p></blockquote> <h4 id="_4-3stringredistemplate常用操作"><a href="#_4-3stringredistemplate常用操作" class="header-anchor">#</a> 4.3StringRedisTemplate常用操作</h4> <blockquote><p>stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;,60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间</p> <p>stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1);//val做-1操作</p> <p>stringRedisTemplate.opsForValue().get(&quot;test&quot;)//根据key获取缓存中的val</p> <p>stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1);//val +1</p> <p>stringRedisTemplate.getExpire(&quot;test&quot;)//根据key获取过期时间</p> <p>stringRedisTemplate.getExpire(&quot;test&quot;,TimeUnit.SECONDS)//根据key获取过期时间并换算成指定单位</p> <p>stringRedisTemplate.delete(&quot;test&quot;);//根据key删除缓存</p> <p>stringRedisTemplate.hasKey(&quot;546545&quot;);//检查key是否存在，返回boolean值</p> <p>stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;,&quot;2&quot;,&quot;3&quot;);//向指定key中存放set集合</p> <p>stringRedisTemplate.expire(&quot;red_123&quot;,1000 , TimeUnit.MILLISECONDS);//设置过期时间</p> <p>stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;)//根据key查看集合中是否存在指定数据</p> <p>stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);//根据key获取set集合</p></blockquote> <h2 id="_5-总结-5"><a href="#_5-总结-5" class="header-anchor">#</a> 5. 总结</h2> <p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p> <h1 id="第15课-spring-boot中集成rabbitmq"><a href="#第15课-spring-boot中集成rabbitmq" class="header-anchor">#</a> 第15课： Spring Boot中集成RabbitMQ</h1> <h1 id="第16课-spring-boot中集成-shiro"><a href="#第16课-spring-boot中集成-shiro" class="header-anchor">#</a> 第16课：Spring Boot中集成 Shiro</h1> <p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p> <h2 id="_1-shiro-三大核心组件"><a href="#_1-shiro-三大核心组件" class="header-anchor">#</a> 1. Shiro 三大核心组件</h2> <p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201216094939870.png" alt="image-20201216094939870"></p> <p>1.Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。</p> <blockquote><p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>
Credentials：凭证。常见有密码，数字证书等等。</p></blockquote> <p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p> <ol start="2"><li><p>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</p></li> <li><p>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</p></li></ol> <h2 id="_1-shiro-身份和权限认证"><a href="#_1-shiro-身份和权限认证" class="header-anchor">#</a> 1. Shiro 身份和权限认证</h2> <h3 id="_1-2-shiro-身份认证"><a href="#_1-2-shiro-身份认证" class="header-anchor">#</a> 1.2 Shiro 身份认证</h3> <p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201216095245457.png" alt="image-20201216095245457"></p> <p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。</p> <p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。</p> <p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p> <h3 id="_1-3-shiro-权限认证"><a href="#_1-3-shiro-权限认证" class="header-anchor">#</a> 1.3 Shiro 权限认证</h3> <p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p> <blockquote><p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；
角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；
用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p></blockquote> <p>它们之间的的关系可以用下图来表示：</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201216095311690.png" alt="image-20201216095311690"></p> <p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p> <h2 id="_2-spring-boot-集成-shiro-过程"><a href="#_2-spring-boot-集成-shiro-过程" class="header-anchor">#</a> 2. Spring Boot 集成 Shiro 过程</h2> <h3 id="_2-1-依赖导入-3"><a href="#_2-1-依赖导入-3" class="header-anchor">#</a> 2.1 依赖导入</h3> <p>Spring Boot 2.2.11 集成 Shiro 需要导入如下 starter 依赖：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.apache.shiro<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>shiro-spring<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">1.4</span>.<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_2-2-数据库表数据初始化"><a href="#_2-2-数据库表数据初始化" class="header-anchor">#</a> 2.2 数据库表数据初始化</h3> <p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CREATE TABLE <span class="token variable"><span class="token variable">`</span>t_role<span class="token variable">`</span></span> <span class="token punctuation">(</span>
  <span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class="token string">'主键'</span>,
  <span class="token variable"><span class="token variable">`</span>rolename<span class="token variable">`</span></span> varchar<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> DEFAULT NULL COMMENT <span class="token string">'角色名称'</span>,
  PRIMARY KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>InnoDB <span class="token assign-left variable">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">4</span> DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8

CREATE TABLE <span class="token variable"><span class="token variable">`</span>t_user<span class="token variable">`</span></span> <span class="token punctuation">(</span>
  <span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class="token string">'用户主键'</span>,
  <span class="token variable"><span class="token variable">`</span>username<span class="token variable">`</span></span> varchar<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> NOT NULL COMMENT <span class="token string">'用户名'</span>,
  <span class="token variable"><span class="token variable">`</span>password<span class="token variable">`</span></span> varchar<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> NOT NULL COMMENT <span class="token string">'密码'</span>,
  <span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> DEFAULT NULL COMMENT <span class="token string">'外键关联role表'</span>,
  PRIMARY KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>,
  KEY <span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span><span class="token punctuation">)</span>,
  CONSTRAINT <span class="token variable"><span class="token variable">`</span>t_user_ibfk_1<span class="token variable">`</span></span> FOREIGN KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span><span class="token punctuation">)</span> REFERENCES <span class="token variable"><span class="token variable">`</span>t_role<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>InnoDB <span class="token assign-left variable">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">4</span> DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8

CREATE TABLE <span class="token variable"><span class="token variable">`</span>t_permission<span class="token variable">`</span></span> <span class="token punctuation">(</span>
  <span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class="token string">'主键'</span>,
  <span class="token variable"><span class="token variable">`</span>permissionname<span class="token variable">`</span></span> varchar<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> NOT NULL COMMENT <span class="token string">'权限名'</span>,
  <span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> DEFAULT NULL COMMENT <span class="token string">'外键关联role'</span>,
  PRIMARY KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>,
  KEY <span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span><span class="token punctuation">)</span>,
  CONSTRAINT <span class="token variable"><span class="token variable">`</span>t_permission_ibfk_1<span class="token variable">`</span></span> FOREIGN KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>role_id<span class="token variable">`</span></span><span class="token punctuation">)</span> REFERENCES <span class="token variable"><span class="token variable">`</span>t_role<span class="token variable">`</span></span> <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>InnoDB <span class="token assign-left variable">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">3</span> DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8
</code></pre></div><p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。
t_user 表：</p> <table><thead><tr><th style="text-align:center;">id</th> <th style="text-align:center;">username</th> <th style="text-align:center;">password</th> <th style="text-align:center;">role_id</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">csdn1</td> <td style="text-align:center;">123456</td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">csdn2</td> <td style="text-align:center;">123456</td> <td style="text-align:center;">2</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">csdn3</td> <td style="text-align:center;">123456</td> <td style="text-align:center;">3</td></tr></tbody></table> <p>t_role 表：</p> <table><thead><tr><th style="text-align:center;">id</th> <th style="text-align:center;">rolename</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">admin</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;">teacher</td></tr> <tr><td style="text-align:center;">3</td> <td style="text-align:center;">student</td></tr></tbody></table> <p>t_permission 表：</p> <table><thead><tr><th style="text-align:center;">id</th> <th style="text-align:center;">permissionname</th> <th style="text-align:center;">role_id</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;"><code>user:*</code></td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:center;">2</td> <td style="text-align:center;"><code>student:*</code></td> <td style="text-align:center;">2</td></tr></tbody></table> <p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p> <h3 id="_2-2-自定义-realm"><a href="#_2-2-自定义-realm" class="header-anchor">#</a> 2.2 自定义 Realm</h3> <p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p> <blockquote><p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br> <code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p></blockquote> <p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 自定义realm
 * 
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRealm</span> <span class="token keyword">extends</span> <span class="token class-name">AuthorizingRealm</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">AuthorizationInfo</span> <span class="token function">doGetAuthorizationInfo</span><span class="token punctuation">(</span><span class="token class-name">PrincipalCollection</span> principalCollection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取用户名</span>
        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> principalCollection<span class="token punctuation">.</span><span class="token function">getPrimaryPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SimpleAuthorizationInfo</span> authorizationInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAuthorizationInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 给该用户设置角色，角色信息存在t_role表中取</span>
        authorizationInfo<span class="token punctuation">.</span><span class="token function">setRoles</span><span class="token punctuation">(</span>userService<span class="token punctuation">.</span><span class="token function">getRoles</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 给该用户设置权限，权限信息存在t_permission表中取</span>
        authorizationInfo<span class="token punctuation">.</span><span class="token function">setStringPermissions</span><span class="token punctuation">(</span>userService<span class="token punctuation">.</span><span class="token function">getPermissions</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> authorizationInfo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">AuthenticationInfo</span> <span class="token function">doGetAuthenticationInfo</span><span class="token punctuation">(</span><span class="token class-name">AuthenticationToken</span> authenticationToken<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释</span>
        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> authenticationToken<span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据用户名从数据库中查询该用户</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getByUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把当前用户存到session中</span>
            <span class="token class-name">SecurityUtils</span><span class="token punctuation">.</span><span class="token function">getSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 传入用户名和密码进行身份认证，并返回认证信息</span>
            <span class="token class-name">AuthenticationInfo</span> authcInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAuthenticationInfo</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;myRealm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> authcInfo<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p> <h3 id="_2-3-shiro-配置"><a href="#_2-3-shiro-配置" class="header-anchor">#</a> 2.3 Shiro 配置</h3> <p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p> <p>配置自定义 realm：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShiroConfig</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ShiroConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 注入自定义的realm
     * @return MyRealm
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">MyRealm</span> <span class="token function">myAuthRealm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyRealm</span> myRealm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRealm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====myRealm注册完成=====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> myRealm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>配置安全管理器 SecurityManager：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShiroConfig</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ShiroConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 注入安全管理器
     * @return SecurityManager
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">SecurityManager</span> <span class="token function">securityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将自定义realm加进来</span>
        <span class="token class-name">DefaultWebSecurityManager</span> securityManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultWebSecurityManager</span><span class="token punctuation">(</span><span class="token function">myAuthRealm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====securityManager注册完成====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> securityManager<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p> <p>配置 Shiro 过滤器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShiroConfig</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ShiroConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 注入Shiro过滤器
     * @param securityManager 安全管理器
     * @return ShiroFilterFactoryBean
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">ShiroFilterFactoryBean</span> <span class="token function">shiroFilter</span><span class="token punctuation">(</span><span class="token class-name">SecurityManager</span> securityManager<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 定义shiroFactoryBean</span>
        <span class="token class-name">ShiroFilterFactoryBean</span> shiroFilterFactoryBean<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ShiroFilterFactoryBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置自定义的securityManager</span>
        shiroFilterFactoryBean<span class="token punctuation">.</span><span class="token function">setSecurityManager</span><span class="token punctuation">(</span>securityManager<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置默认登录的url，身份认证失败会访问该url</span>
        shiroFilterFactoryBean<span class="token punctuation">.</span><span class="token function">setLoginUrl</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置成功之后要跳转的链接</span>
        shiroFilterFactoryBean<span class="token punctuation">.</span><span class="token function">setSuccessUrl</span><span class="token punctuation">(</span><span class="token string">&quot;/success&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置未授权界面，权限认证失败会访问该url</span>
        shiroFilterFactoryBean<span class="token punctuation">.</span><span class="token function">setUnauthorizedUrl</span><span class="token punctuation">(</span><span class="token string">&quot;/unauthorized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// LinkedHashMap是有序的，进行顺序拦截器配置</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> filterChainMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/css/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/imgs/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/js/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/swagger-*/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/swagger-ui.html/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 登录url 放行</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;anon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// “/user/admin” 开头的需要身份认证，authc表示要身份认证</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/user/admin*&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;authc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// “/user/student” 开头的需要角色认证，是“admin”才允许</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/user/student*/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;roles[admin]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// “/user/teacher” 开头的需要权限认证，是“user:create”才允许</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/user/teacher*/**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;perms[\&quot;user:create\&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 配置logout过滤器</span>
        filterChainMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;/logout&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;logout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置shiroFilterFactoryBean的FilterChainDefinitionMap</span>
        shiroFilterFactoryBean<span class="token punctuation">.</span><span class="token function">setFilterChainDefinitionMap</span><span class="token punctuation">(</span>filterChainMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;====shiroFilterFactoryBean注册完成====&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> shiroFilterFactoryBean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p> <blockquote><p>默认登录的 url：身份认证失败会访问该 url
认证成功之后要跳转的 url
权限认证失败会访问该 url
需要拦截或者放行的 url：这些都放在一个 map 中</p></blockquote> <p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。</p> <table><thead><tr><th style="text-align:center;">Filter</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">anon</td> <td style="text-align:center;">开放权限，可以理解为匿名用户或游客，可以直接访问的</td></tr> <tr><td style="text-align:center;">authc</td> <td style="text-align:center;">需要身份认证的</td></tr> <tr><td style="text-align:center;">logout</td> <td style="text-align:center;">注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面</td></tr> <tr><td style="text-align:center;">roles[admin]</td> <td style="text-align:center;">参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[&quot;admin，user&quot;]，当有多个参数时必须每个参数都通过才算通过</td></tr> <tr><td style="text-align:center;">perms[user]</td> <td style="text-align:center;">参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过</td></tr></tbody></table> <h3 id="_2-4-使用-shiro-进行认证"><a href="#_2-4-使用-shiro-进行认证" class="header-anchor">#</a> 2.4 使用 Shiro 进行认证</h3> <p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p> <blockquote><p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证
接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证
接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证
接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p></blockquote> <p>然后来一下认证的流程：</p> <blockquote><p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。
流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。
流程三： 访问接口二，测试角色认证是否成功。
流程四： 访问接口三，测试权限认证是否成功。</p></blockquote> <h4 id="_2-4-1-身份、角色、权限认证接口"><a href="#_2-4-1-身份、角色、权限认证接口" class="header-anchor">#</a> 2.4.1 身份、角色、权限认证接口</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 身份认证测试接口
     * @param request
     * @return
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/admin&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">admin</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> user <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 角色认证测试接口
     * @param request
     * @return
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/student&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 权限认证测试接口
     * @param request
     * @return
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/teacher&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">teacher</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p> <h4 id="_2-4-2-用户登录接口"><a href="#_2-4-2-用户登录接口" class="header-anchor">#</a> 2.4.2 用户登录接口</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 用户登录接口
     * @param user user
     * @param request request
     * @return string
     */</span>
    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// 根据用户名和密码创建token</span>
        <span class="token class-name">UsernamePasswordToken</span> token <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordToken</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取subject认证主体</span>
        <span class="token class-name">Subject</span> subject <span class="token operator">=</span> <span class="token class-name">SecurityUtils</span><span class="token punctuation">.</span><span class="token function">getSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            <span class="token comment">// 开始认证，这一步会跳到我们自定义的realm中</span>
            subject<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
            request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;用户名或密码错误！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">&quot;login&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p> <h4 id="_2-4-3-测试一下"><a href="#_2-4-3-测试一下" class="header-anchor">#</a> 2.4.3 测试一下</h4> <p>最后，启动项目，测试一下：
浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p> <p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p> <h2 id="_3-总结-3"><a href="#_3-总结-3" class="header-anchor">#</a> 3. 总结</h2> <p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p> <h1 id="第17课-spring-boot中集成elasticsearch"><a href="#第17课-spring-boot中集成elasticsearch" class="header-anchor">#</a> 第17课：Spring Boot中集成ElasticSearch</h1> <h1 id="第18课-spring-boot中集成mybatis-plus"><a href="#第18课-spring-boot中集成mybatis-plus" class="header-anchor">#</a> 第18课：Spring Boot中集成Mybatis-Plus</h1> <p>Mybatis-Plus简称 MP 是一个mybatis的增强工具，在mybatis的基础上只做增强，不做改变，为简化开发 提高效率而生，MP 提供了代码生成器，可以一键生成controller  service  mapper  model  mapper.xml 代码，同时 提供丰富的CRUD 操作方法，帮助我们成大事！！！</p> <h2 id="_1-简介"><a href="#_1-简介" class="header-anchor">#</a> 1.简介</h2> <blockquote><p>官网：http://mp.baomidou.com/</p> <p>参考教程：http://mp.baomidou.com/guide/</p> <p><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener noreferrer">MyBatis-Plus<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener noreferrer">MyBatis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p></blockquote> <h2 id="_2-特性"><a href="#_2-特性" class="header-anchor">#</a> 2.特性</h2> <blockquote><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li> <li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li> <li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li> <li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li> <li><strong>支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</li> <li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li> <li><strong>支持 XML 热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</li> <li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li> <li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li> <li><strong>支持关键词自动转义</strong>：支持数据库关键词（order、key......）自动转义，还可自定义关键词</li> <li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li> <li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li> <li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li> <li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li> <li><strong>内置 Sql 注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li></ul></blockquote> <h2 id="_3-入门"><a href="#_3-入门" class="header-anchor">#</a> 3.入门</h2> <h4 id="_3-1-准备工作"><a href="#_3-1-准备工作" class="header-anchor">#</a> 3.1 准备工作</h4> <blockquote><p>创建springboot 项目</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>group：  com.glls
Artifact：mybatis-plus
<span class="token comment"># pom 文件 </span>
<span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">&quot;1.0&quot;</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span><span class="token string">&quot;UTF-8&quot;</span>?<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>project <span class="token assign-left variable">xmlns</span><span class="token operator">=</span><span class="token string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi<span class="token operator">=</span><span class="token string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
         xsi:schemaLocation<span class="token operator">=</span><span class="token string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>modelVersion<span class="token operator">&gt;</span><span class="token number">4.0</span>.<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/modelVersion<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>parent<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter-parent<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">2.2</span>.6.RELEASE<span class="token operator">&lt;</span>/version<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>relativePath/<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">!</span>-- lookup parent from repository --<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/parent<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.glls<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-plus<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">0.0</span>.1-SNAPSHOT<span class="token operator">&lt;</span>/version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>mybatis-plus<span class="token operator">&lt;</span>/name<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>description<span class="token operator">&gt;</span>Demo project <span class="token keyword">for</span> Spring Boot<span class="token operator">&lt;</span>/description<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>properties<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>java.version<span class="token operator">&gt;</span><span class="token number">1</span>.<span class="token operator"><span class="token file-descriptor important">8</span>&lt;</span>/java.version<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/properties<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>dependencies<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>

        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-starter-test<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>scope<span class="token operator">&gt;</span>test<span class="token operator">&lt;</span>/scope<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>exclusions<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>exclusion<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.junit.vintage<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>junit-vintage-engine<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>/exclusion<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/exclusions<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>

        <span class="token operator">&lt;</span><span class="token operator">!</span>--mysql--<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>mysql<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mysql-connector-java<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>scope<span class="token operator">&gt;</span>runtime<span class="token operator">&lt;</span>/scope<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span><span class="token operator">!</span>--使用lombok 记得装插件--<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.projectlombok<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>lombok<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>optional<span class="token operator">&gt;</span>true<span class="token operator">&lt;</span>/optional<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>


        <span class="token operator">&lt;</span><span class="token operator">!</span>--mybatis-plus--<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.baomidou<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-plus-boot-starter<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.4</span>.<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/version<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>


		<span class="token operator">&lt;</span><span class="token operator">!</span>--mybatis-plus代码生成器--<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.baomidou<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-plus-generator<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.3</span>.<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/version<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span><span class="token operator">!</span>--模板   代码生成器需要使用模板进行生成--<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.apache.velocity<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>velocity<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">1</span>.<span class="token operator"><span class="token file-descriptor important">7</span>&lt;</span>/version<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
		
		<span class="token operator">&lt;</span><span class="token operator">!</span>--mybatis-plus 扩展插件  比如  分页插件依赖--<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>com.baomidou<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>mybatis-plus-extension<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
			<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.4</span>.<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/version<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>


    <span class="token operator">&lt;</span>/dependencies<span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span>build<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>plugins<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>plugin<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-maven-plugin<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/plugin<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/plugins<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/build<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>/project<span class="token operator">&gt;</span>

</code></pre></div><p>**注意：**引入 MyBatis-Plus 之后请不要再次引入 MyBatis 以及 MyBatis-Spring，以避免因版本差异导致的问题。</p> <blockquote><p>创建数据 库     mybatis_plus</p></blockquote> <blockquote><p>创建User 表</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201007164549548.png" alt="image-20201007164549548"></p> <p>其对应的数据库 Schema 脚本如下：</p> <p>DROP TABLE IF EXISTS user;</p> <p>CREATE TABLE user
(
id BIGINT(20) NOT NULL COMMENT '主键ID',
name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',
age INT(11) NULL DEFAULT NULL COMMENT '年龄',
email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',
PRIMARY KEY (id)
);</p> <p>其对应的数据库 Data 脚本如下：</p> <p>DELETE FROM user;
INSERT INTO user (id, name, age, email) VALUES
(1, 'Jone', 18, 'test1@baomidou.com'),
(2, 'Jack', 20, 'test2@baomidou.com'),
(3, 'Tom', 28, 'test3@baomidou.com'),
(4, 'Sandy', 21, 'test4@baomidou.com'),
(5, 'Billie', 24, 'test5@baomidou.com');</p></blockquote> <blockquote><p>spring boot 配置文件</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone<span class="token operator">=</span>GMT%2B8
    username: root
    password: <span class="token number">123456</span>

mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl        <span class="token comment">#  查看sql输出日志</span>
</code></pre></div><p>**注意：**driver和url的变化</p> <p>1、这里的 url 使用了 ?serverTimezone=GMT%2B8 后缀，因为Spring Boot 2.1 集成了 8.0版本的jdbc驱动，这个版本的 jdbc 驱动需要添加这个后缀，否则运行测试用例报告如下错误：</p> <p>java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more</p> <p>2、这里的 driver-class-name 使用了 com.mysql.cj.jdbc.Driver ，在 jdbc 8 中 建议使用这个驱动，之前的 com.mysql.jdbc.Driver 已经被废弃，否则运行测试用例的时候会有 WARN 信息</p> <h4 id="_3-2编写代码"><a href="#_3-2编写代码" class="header-anchor">#</a> 3.2编写代码</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 1.启动类</span>
<span class="token comment">#启动类添加 @MapperScan 注解  ，扫描mapper 包下的接口</span>
@SpringBootApplication
@MapperScan<span class="token punctuation">(</span><span class="token string">&quot;com.glls.mybatisplus.mapper&quot;</span><span class="token punctuation">)</span>
public class MybatisPlusApplication <span class="token punctuation">{</span>
    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SpringApplication.run<span class="token punctuation">(</span>MybatisPlusApplication.class, args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token comment">#2.实体类  在pojo 下 创建User.java  使用lombok 简化代码</span>
@Data
public class User <span class="token punctuation">{</span>
    //@TableId<span class="token punctuation">(</span>type <span class="token operator">=</span> IdType.AUTO<span class="token punctuation">)</span>
    private Long <span class="token function">id</span><span class="token punctuation">;</span>
    private String name<span class="token punctuation">;</span>
    private Integer age<span class="token punctuation">;</span>
    private String email<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">#3. 创建mapper 包  创建UserMapper 接口 UserMapper.java</span>
@Repository
public interface UserMapper extends BaseMapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意：</strong></p> <p>IDEA在 userMapper 处报错，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确的执行。</p> <p>为了避免报错，可以在 mapper 层 的接口上添加 @Repository 注</p> <h4 id="_3-3测试-创建-测试类"><a href="#_3-3测试-创建-测试类" class="header-anchor">#</a> 3.3测试   创建 测试类</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>@SpringBootTest
class UserMapperTest <span class="token punctuation">{</span>
    @Autowired
    private UserMapper userMapper<span class="token punctuation">;</span>

    @Test
    public void <span class="token function-name function">testSelectList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System.out.println<span class="token variable"><span class="token punctuation">((</span>&quot;<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> selectAll method testdemo <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>&quot;<span class="token punctuation">))</span></span><span class="token punctuation">;</span>
        //UserMapper 中的 selectList<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法的参数为 MP 内置的条件封装器 Wrapper
        //所以不填写就是无任何条件
        List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
</code></pre></div><p>控制台输出：</p> <p>User(id=1, name=ww, age=22, email=test1@baomidou.com)
User(id=2, name=Jack, age=20, email=test2@baomidou.com)
User(id=3, name=Tom, age=28, email=test3@baomidou.com)
User(id=4, name=Sandy, age=21, email=test4@baomidou.com)
User(id=5, name=Billie, age=24, email=test5@baomidou.com)
User(id=11, name=Helen, age=18, email=55317332@qq.com)</p> <p>通过以上几个简单的步骤，我们就实现了 User 表的    基本查询   功能，甚至连 XML 文件都不用编写！</p> <h2 id="_4-mp-实现crud"><a href="#_4-mp-实现crud" class="header-anchor">#</a> 4. mp 实现crud</h2> <h4 id="_4-1-insert"><a href="#_4-1-insert" class="header-anchor">#</a> 4.1 insert</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>   @Test
    public void <span class="token function-name function">testInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        User user <span class="token operator">=</span> new User<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user.setName<span class="token punctuation">(</span><span class="token string">&quot;libai&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user.setAge<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user.setEmail<span class="token punctuation">(</span><span class="token string">&quot;55317332@qq.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        int result <span class="token operator">=</span> userMapper.insert<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> //影响的行数
        System.out.println<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> //id自动回填
    <span class="token punctuation">}</span>
</code></pre></div><p>**注意：**数据库插入id值默认为：全局唯一id</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201007181219875.png" alt="image-20201007181219875"></p> <h4 id="_4-2-主键策略"><a href="#_4-2-主键策略" class="header-anchor">#</a> 4.2 主键策略</h4> <blockquote><p><strong>ID_WORKER</strong></p> <p>MyBatis-Plus默认的主键策略是：ID_WORKER  <em>全局唯一ID</em></p> <p>**参考资料：分布式系统唯一ID生成方案汇总：**https://www.cnblogs.com/haoxinyue/p/5208136.html</p> <p>常用的分布式id 生成策略</p> <p>mysql  数据库自动增长</p> <p>redis 的原子操作</p> <p>mp 自带的自增长策略 ，使用 snowflake 算法</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#使用IdWorker工具类测试id的生成，了解id生成原理</span>
<span class="token comment">#添加工具类：IdWorker.java</span>
<span class="token comment">#编写测试用例：</span>
@Test
public void <span class="token function-name function">testIdWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    long <span class="token function">id</span> <span class="token operator">=</span> new IdWorker<span class="token punctuation">(</span><span class="token punctuation">)</span>.nextId<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System.out.println<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>自增策略</strong></p> <div class="language- extra-class"><pre><code>  要想主键自增需要配置如下主键策略
</code></pre></div><ul><li><p>需要在创建数据表的时候设置主键自增</p></li> <li><p>实体字段中配置 @TableId(type = IdType.AUTO)</p></li></ul></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>@TableId<span class="token punctuation">(</span>type <span class="token operator">=</span> IdType.AUTO<span class="token punctuation">)</span>      // 使用 数据库的 自增策略       默认是 IdType.ID_WORKER    雪花算法生成的id
private Long <span class="token function">id</span><span class="token punctuation">;</span>
</code></pre></div><p>要想影响所有实体的配置，可以设置全局主键配置</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#全局设置主键生成策略</span>
mybatis-plus.global-config.db-config.id-type<span class="token operator">=</span>auto
</code></pre></div><p>其它主键策略：分析 IdType 源码可知</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Getter
public enum IdType <span class="token punctuation">{</span>

    /**
     * 数据库ID自增
     */
    AUTO<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>,
    /**
     * 该类型为未设置主键类型
     */
    NONE<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>,
    /**
     * 用户输入ID
     * 该类型可以通过自己注册自动填充插件进行填充
     */
    INPUT<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>,
    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 全局唯一ID <span class="token punctuation">(</span>idWorker<span class="token punctuation">)</span>
     */
    ID_WORKER<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>,
    /**
     * 全局唯一ID <span class="token punctuation">(</span>UUID<span class="token punctuation">)</span>
     */
    UUID<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>,
    /**
     * 字符串全局唯一ID <span class="token punctuation">(</span>idWorker 的字符串表示<span class="token punctuation">)</span>
     */
    ID_WORKER_STR<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    private int key<span class="token punctuation">;</span>
    IdType<span class="token punctuation">(</span>int key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this.key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-3-update"><a href="#_4-3-update" class="header-anchor">#</a> 4.3 update</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>根据id 更新操作   注意：update时生成的sql自动是动态sql：UPDATE user SET <span class="token assign-left variable">age</span><span class="token operator">=</span>? WHERE <span class="token assign-left variable">id</span><span class="token operator">=</span>? 

@Test
    public void <span class="token function-name function">testUpdateById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        User user <span class="token operator">=</span> userMapper.selectById<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user.setAge<span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user.setName<span class="token punctuation">(</span><span class="token string">&quot;ww&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        int result <span class="token operator">=</span> userMapper.updateById<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-4-自动填充"><a href="#_4-4-自动填充" class="header-anchor">#</a> 4.4 自动填充</h4> <blockquote><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。</p> <p>我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作：</p> <p><strong>1.数据库表中添加自动填充字段</strong></p> <p>在User表中添加datetime类型的新的字段 create_time、update_time</p> <p><strong>2.实体上添加注解</strong></p> <p>@Data
public class User {
......</p> <p>@TableField(fill = FieldFill.INSERT)       // 添加时 赋值
private Date createTime;
//@TableField(fill = FieldFill.UPDATE)      修改时 赋值<br>
@TableField(fill = FieldFill.INSERT_UPDATE)           //  添加  和  修改 都会赋值
private Date updateTime;
}</p> <p><strong>3.实现元对象处理器接口</strong> <strong>注意：不要忘记添加 @Component 注解</strong></p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.mybatisplus.handler<span class="token punctuation">;</span>

<span class="token function">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler<span class="token punctuation">;</span>
<span class="token function">import</span> org.apache.ibatis.reflection.MetaObject<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.Logger<span class="token punctuation">;</span>
<span class="token function">import</span> org.slf4j.LoggerFactory<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.stereotype.Component<span class="token punctuation">;</span>

<span class="token function">import</span> java.util.Date<span class="token punctuation">;</span>

@Component
public class MyMetaObjectHandler implements MetaObjectHandler <span class="token punctuation">{</span>
    private static final Logger LOGGER <span class="token operator">=</span> LoggerFactory.getLogger<span class="token punctuation">(</span>MyMetaObjectHandler.class<span class="token punctuation">)</span><span class="token punctuation">;</span>

    @Override
    public void insertFill<span class="token punctuation">(</span>MetaObject metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;start insert fill ....&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        this.setFieldValByName<span class="token punctuation">(</span><span class="token string">&quot;createTime&quot;</span>, new Date<span class="token punctuation">(</span><span class="token punctuation">)</span>, metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        this.setFieldValByName<span class="token punctuation">(</span><span class="token string">&quot;updateTime&quot;</span>, new Date<span class="token punctuation">(</span><span class="token punctuation">)</span>, metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    @Override
    public void updateFill<span class="token punctuation">(</span>MetaObject metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         LOGGER.info<span class="token punctuation">(</span><span class="token string">&quot;start insert fill ....&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        this.setFieldValByName<span class="token punctuation">(</span><span class="token string">&quot;updateTime&quot;</span>, new Date<span class="token punctuation">(</span><span class="token punctuation">)</span>, metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment"># 测试 添加  修改  操作</span>
</code></pre></div><h4 id="_4-5-乐观锁"><a href="#_4-5-乐观锁" class="header-anchor">#</a> 4.5 乐观锁</h4> <blockquote><p>**主要适用场景：**当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新</p> <p><strong>乐观锁实现方式：</strong></p> <ul><li>取出记录时，获取当前version</li> <li>更新时，带上这个version</li> <li>执行更新时， set version = newVersion where version = oldVersion</li> <li>如果version不对，就更新失败</li></ul></blockquote> <blockquote><p><strong>1.数据库中添加</strong>version字段</p> <p>ALTER TABLE <code>user</code> ADD COLUMN <code>version</code> INT</p> <p><strong>2.实体类添加version字段</strong>**   并添加 @Version 注解</p> <div class="language- extra-class"><pre class="language-text"><code>@Version
@TableField(fill = FieldFill.INSERT)
private Integer version;
</code></pre></div><p><strong>3.元对象处理器接口添加version的insert默认值</strong></p> <div class="language- extra-class"><pre class="language-text"><code>@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
private static final Logger LOGGER = LoggerFactory.getLogger(MyMetaObjectHandler.class);

@Override
public void insertFill(MetaObject metaObject) {
LOGGER.info(&quot;start insert fill ....&quot;);
this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);
this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);

// 添加 乐观锁的  默认值是 1
this.setFieldValByName(&quot;version&quot;, 1, metaObject);

}

@Override
public void updateFill(MetaObject metaObject) {
LOGGER.info(&quot;start update fill ....&quot;);
this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);
}
}

</code></pre></div><p><strong>特别说明:</strong></p> <p>支持的数据类型只有 int,Integer,long,Long,Date,Timestamp,LocalDateTime</p> <p>整数类型下 <code>newVersion = oldVersion + 1``newVersion</code> 会回写到 <code>entity</code> 中</p> <p>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</p> <p>在 <code>update(entity, wrapper)</code> 方法下, <code>wrapper</code> 不能复用!!!</p> <p><strong>4.在 MybatisPlusConfig 中注册 bean</strong></p> <p>创建配置类</p> <div class="language- extra-class"><pre class="language-text"><code>@EnableTransactionManagement
@Configuration
//@MapperScan(&quot;com.glls.mybatisplus.mapper&quot;)    // mapper 的扫描 写在一个地方就可以
public class MybatisPlusConfig {

/**
 * 乐观锁插件
 */
@Bean
public OptimisticLockerInterceptor optimisticLockerInterceptor() {
    return new OptimisticLockerInterceptor();
}

}
</code></pre></div><p>5.<strong>测试乐观锁已修改成功</strong></p> <p>测试后分析打印的sql语句，将version的数值进行了加1操作</p> <div class="language-shell extra-class"><pre class="language-shell"><code>// 测试 乐观锁  修改成功
@Test
public void <span class="token function-name function">testUpdateById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
User user <span class="token operator">=</span> userMapper.selectById<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setAge<span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setName<span class="token punctuation">(</span><span class="token string">&quot;zs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
int result <span class="token operator">=</span> userMapper.updateById<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>// 测试乐观锁 修改失败   这两个方法都打断点  断点都打到修改操作 和 查询操作之间   先执行上面的，执行到断点处，停下  再执行下面的，执行
//到断点处  放行 让下面这个方法 先执行完   更新了  version 值 ，上面的方法 再放行  version 就对不上了 ，上面的 修改失败   
@Test
public void <span class="token function-name function">testUpdateById2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
User user <span class="token operator">=</span> userMapper.selectById<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setAge<span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setName<span class="token punctuation">(</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
int result <span class="token operator">=</span> userMapper.updateById<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <blockquote><p>测试  有乐观锁插件 情况下   wrapper  不能服用</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//有乐观锁插件 wrapper 不能服用问题
@Test
public void testWrapperNoReUse(){

    LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = Wrappers.lambdaQuery();
    userLambdaQueryWrapper.eq(User::getId , &quot;1&quot;);

    User user1 = userMapper.selectById(&quot;1&quot;);
    int version1 = user1.getVersion();
    user1.setName(&quot;xxxx&quot;+version1);
    user1.setVersion(version1);

    int rows1 = userMapper.update(user1 , userLambdaQueryWrapper);
    System.out.println(&quot;影响行数： &quot;+rows1);

    System.out.println(&quot;-------------------------------------------&quot;);

    User user2 = userMapper.selectById(&quot;1&quot;);
    int version2 = user2.getVersion();
    user2.setName(&quot;yyyyy&quot;+version2);
    user2.setVersion(version2);

    int rows2 = userMapper.update(user2 , userLambdaQueryWrapper);
    System.out.println(&quot;影响行数： &quot;+rows2);
}
</code></pre></div><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210517165747137.png" alt="image-20210517165747137"></p> <p>可以看到第一次更新是正常的，而第二次更新的<code>sql</code>语句是有问题的，<code>version</code>在<code>WHERE</code>条件中出现了两次，且值还不一样，所以这肯定是更新不到数据的。</p> <p>UPDATE user SET name=?, age=?, email=?, update_time=?, version=? WHERE (id = ? AND version = ? AND version = ?)</p> <p><strong>所以，要记住，有乐观锁插件的时候     在 <code>update(entity, wrapper)</code> 方法下, wrapper 不能复用。</strong></p> <h4 id="_4-6-select"><a href="#_4-6-select" class="header-anchor">#</a> 4.6 select</h4> <blockquote><p>根据id 查询</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>  @Test
    public void <span class="token function-name function">testSelectById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        User user <span class="token operator">=</span> userMapper.selectById<span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>通过多个id批量查询</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
    public void <span class="token function-name function">testSelectBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectBatchIds<span class="token punctuation">(</span>Arrays.asList<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>简单的条件查询    通过map 封装查询条件</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>  @Test
    public void <span class="token function-name function">testSelectByMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        //注意：map中的key对应的是数据库中的列名。例如数据库user_id，实体类是userId，这时map的key需要填写user_id
        HashMap<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;Helen&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectByMap<span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token comment"># 注意：map中的key对应的是数据库中的列名。例如数据库user_id，实体类是userId，这时map的key需要填写user_id</span>
</code></pre></div><blockquote><p>分页     MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p> <ol><li>创建配置类</li></ol></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>    /**
     * 分页插件    注意  高版本的mybatis-plus 分页插件  及 乐观锁插件都有所变化 
     */
     //旧版本
    //@Bean
    //public PaginationInnerInterceptor <span class="token function-name function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    //    <span class="token builtin class-name">return</span> new PaginationInnerInterceptor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    //<span class="token punctuation">}</span>
    
    //新版本
     @Bean
    public MybatisPlusInterceptor <span class="token function-name function">optimisticLockerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        MybatisPlusInterceptor interceptor <span class="token operator">=</span> new MybatisPlusInterceptor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        PaginationInnerInterceptor paginationInnerInterceptor <span class="token operator">=</span> new PaginationInnerInterceptor<span class="token punctuation">(</span>DbType.MYSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor.addInnerInterceptor<span class="token punctuation">(</span>paginationInnerInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 添加分页拦截器  --- 分页插件

        OptimisticLockerInnerInterceptor optimisticLockerInnerInterceptor <span class="token operator">=</span> new OptimisticLockerInnerInterceptor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        interceptor.addInnerInterceptor<span class="token punctuation">(</span>optimisticLockerInnerInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>   // 添加乐观锁拦截器 --- 乐观锁插件
        <span class="token builtin class-name">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    
    
</code></pre></div><blockquote><p>2.测试selectPage 分页   **测试：**最终通过page对象获取相关数据</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
    public void <span class="token function-name function">testSelectPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        //MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能
        Page<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> page <span class="token operator">=</span> new Page<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token number">1,5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        userMapper.selectPage<span class="token punctuation">(</span>page, null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        page.getRecords<span class="token punctuation">(</span><span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getCurrent<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getPages<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>   // 总页
        System.out.println<span class="token punctuation">(</span>page.getSize<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getTotal<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span> // 总记录数
        System.out.println<span class="token punctuation">(</span>page.hasNext<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span> // 是否有下一页
        System.out.println<span class="token punctuation">(</span>page.hasPrevious<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span> // 是否有上一页
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>3.测试selectMapsPage分页：结果集是Map</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>    @Test
    public void <span class="token function-name function">testSelectMapsPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Page page <span class="token operator">=</span> new Page<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span>, <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        IPage<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;&gt;</span> mapIPage <span class="token operator">=</span> userMapper.selectMapsPage<span class="token punctuation">(</span>page, null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        //注意：此行必须使用 mapIPage 获取记录列表，否则会有数据类型转换错误
        mapIPage.getRecords<span class="token punctuation">(</span><span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getCurrent<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getPages<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getSize<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.getTotal<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.hasNext<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>page.hasPrevious<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h4 id="_4-7delete"><a href="#_4-7delete" class="header-anchor">#</a> 4.7delete</h4> <blockquote><p>根据id删除记录</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>    //物理   删除
    @Test
    public void <span class="token function-name function">testDeleteById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        // 物理删除一条
        int result <span class="token operator">=</span> userMapper.deleteById<span class="token punctuation">(</span>9L<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>批量删除</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>   // 物理删除 多条
    @Test
    public void <span class="token function-name function">testDeleteBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int result <span class="token operator">=</span> userMapper.deleteBatchIds<span class="token punctuation">(</span>Arrays.asList<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token number">9</span>, <span class="token number">10</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>简单的条件查询删除</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
    public void <span class="token function-name function">testDeleteByMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        //简单的条件查询删除
        HashMap<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;Helen&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map.put<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        int result <span class="token operator">=</span> userMapper.deleteByMap<span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>逻辑删除</p> <p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据
逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p> <p>1.数据库中添加 deleted字段</p> <div class="language-shell extra-class"><pre class="language-shell"><code>ALTER TABLE <span class="token variable"><span class="token variable">`</span>user<span class="token variable">`</span></span> ADD COLUMN <span class="token variable"><span class="token variable">`</span>deleted<span class="token variable">`</span></span> boolean
</code></pre></div><p>2.实体类添加deleted 字段   并加上 @TableLogic 注解 和 @TableField(fill = FieldFill.INSERT) 注解</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@TableLogic
@TableField<span class="token punctuation">(</span>fill <span class="token operator">=</span> FieldFill.INSERT<span class="token punctuation">)</span>
private Integer deleted<span class="token punctuation">;</span>
</code></pre></div><p>3.元对象处理器接口添加deleted的insert默认值</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Override
public void insertFill<span class="token punctuation">(</span>MetaObject metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
this.setFieldValByName<span class="token punctuation">(</span><span class="token string">&quot;deleted&quot;</span>, <span class="token number">0</span>, metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4.配置文件中 加入配置   此为默认值，如果你的默认值和mp默认的一样,该配置可无</p> <div class="language-shell extra-class"><pre class="language-shell"><code>mybatis-plus.global-config.db-config.logic-delete-value<span class="token operator">=</span><span class="token number">1</span>
mybatis-plus.global-config.db-config.logic-not-delete-value<span class="token operator">=</span><span class="token number">0</span>
</code></pre></div><p>5.在 MybatisPlusConfig 中注册 Bean</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Bean
public ISqlInjector <span class="token function-name function">sqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token builtin class-name">return</span> new DefaultSqlInjector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>6.测试逻辑删除</p> <ul><li><p>测试后发现，数据并没有被删除，deleted字段的值由0变成了1</p></li> <li><p>测试后分析打印的sql语句，是一条update</p></li> <li><p>**注意：**被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作</p></li></ul> <p>测试逻辑删除</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
   public void <span class="token function-name function">testLogicDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       int result <span class="token operator">=</span> userMapper.deleteById<span class="token punctuation">(</span>12L<span class="token punctuation">)</span><span class="token punctuation">;</span>
       System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre></div><p>7.测试逻辑删除后的查询   MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
* 测试 逻辑删除后的查询：
* 不包括被逻辑删除的记录
*/
@Test
public void <span class="token function-name function">testLogicDeleteSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  User user <span class="token operator">=</span> new User<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
  users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>测试后分析打印的sql语句，包含 WHERE deleted=0</p></blockquote> <h2 id="_5-条件构造器-wrapper"><a href="#_5-条件构造器-wrapper" class="header-anchor">#</a> 5.条件构造器-wrapper</h2> <h3 id="_5-1wrapper介绍"><a href="#_5-1wrapper介绍" class="header-anchor">#</a> 5.1wrapper介绍</h3> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20201009214327924.png" alt="image-20201009214327924"></p> <blockquote><p>Wrapper ： 条件构造抽象类，最顶端父类</p> <p>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p> <p>QueryWrapper ： Entity 对象封装操作类，不是用lambda语法</p> <p>UpdateWrapper ： Update 条件封装，用于Entity对象更新操作</p> <p>AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。</p> <p>LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper</p> <p>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p></blockquote> <h3 id="_5-2abstractwrapper"><a href="#_5-2abstractwrapper" class="header-anchor">#</a> 5.2AbstractWrapper</h3> <blockquote><p>注意：以下条件构造器的方法入参中的 column 均表示数据库字段
1、ge、gt、le、lt、isNull、isNotNull</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper
.isNull<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span>
.ge<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">12</span><span class="token punctuation">)</span>
.isNotNull<span class="token punctuation">(</span><span class="token string">&quot;email&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
int result <span class="token operator">=</span> userMapper.delete<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span><span class="token string">&quot;delete return count = &quot;</span> + result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment"># SQL：UPDATE user SET deleted=1 WHERE deleted=0 AND name IS NULL AND age &gt;= ? AND email IS NOT NULL</span>
</code></pre></div></blockquote> <blockquote><p>2、eq、ne
注意：seletOne返回的是一条实体记录，当出现多条时会报错</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper.eq<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;Tom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
User user <span class="token operator">=</span> userMapper.selectOne<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment"># SELECT id,name,age,email,create_time,update_time,deleted,version FROM user WHERE deleted=0 AND name = ? </span>
</code></pre></div></blockquote> <blockquote><p>3、between、notBetween
包含大小边界</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper.between<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">20</span>, <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer count <span class="token operator">=</span> userMapper.selectCount<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment"># SELECT COUNT(1) FROM user WHERE deleted=0 AND age BETWEEN ? AND ? </span>
</code></pre></div></blockquote> <blockquote><p>4、allEq</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;</span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	map.put<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span>, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	map.put<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;Jack&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	map.put<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	queryWrapper.allEq<span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
	List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
SELECT id,name,age,email,create_time,update_time,deleted,version 
FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND name <span class="token operator">=</span> ? AND <span class="token function">id</span> <span class="token operator">=</span> ? AND age <span class="token operator">=</span> ?
</code></pre></div></blockquote> <blockquote><p>5、like、notLike、likeLeft、likeRight
selectMaps返回Map集合列表</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper
.notLike<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;e&quot;</span><span class="token punctuation">)</span>
.likeRight<span class="token punctuation">(</span><span class="token string">&quot;email&quot;</span>, <span class="token string">&quot;t&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String, Object<span class="token operator">&gt;&gt;</span> maps <span class="token operator">=</span> userMapper.selectMaps<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>//返回值是Map列表
	maps.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
SELECT id,name,age,email,create_time,update_time,deleted,version 
FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND name NOT LIKE ? AND email LIKE ? 
</code></pre></div></blockquote> <blockquote><p>6、in、notIn、inSql、notinSql、exists、notExists
in、notIn：
notIn(&quot;age&quot;,{1,2,3})---&gt;age not in (1,2,3)
notIn(&quot;age&quot;, 1, 2, 3)---&gt;age not in (1,2,3)
inSql、notinSql：可以实现子查询
例: inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)---&gt;age in (1,2,3,4,5,6)
例: inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectObjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//queryWrapper.in<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span>, <span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper.inSql<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span>, <span class="token string">&quot;select id from user where id &lt; 3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> objects <span class="token operator">=</span> userMapper.selectObjs<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>//返回值是Object列表
objects.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
SELECT id,name,age,email,create_time,update_time,deleted,version 
FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND <span class="token function">id</span> IN <span class="token punctuation">(</span>select <span class="token function">id</span> from user where <span class="token function">id</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> 
</code></pre></div></blockquote> <blockquote><p>7、or、and
注意：这里使用的是 UpdateWrapper
不调用or则默认为使用 and 连</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testUpdate1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
//修改值
User user <span class="token operator">=</span> new User<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setAge<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setName<span class="token punctuation">(</span><span class="token string">&quot;Andy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//修改条件
UpdateWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> userUpdateWrapper <span class="token operator">=</span> new UpdateWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userUpdateWrapper
.like<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;h&quot;</span><span class="token punctuation">)</span>
.or<span class="token punctuation">(</span><span class="token punctuation">)</span>
.between<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">20</span>, <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

int result <span class="token operator">=</span> userMapper.update<span class="token punctuation">(</span>user, userUpdateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>

System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
UPDATE user SET <span class="token assign-left variable">name</span><span class="token operator">=</span>?, <span class="token assign-left variable">age</span><span class="token operator">=</span>?, <span class="token assign-left variable">update_time</span><span class="token operator">=</span>? WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND name LIKE ? OR age BETWEEN ? AND ?
</code></pre></div></blockquote> <blockquote><p>8、嵌套or、嵌套and
这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testUpdate2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

//修改值
User user <span class="token operator">=</span> new User<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setAge<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setName<span class="token punctuation">(</span><span class="token string">&quot;Andy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//修改条件
UpdateWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> userUpdateWrapper <span class="token operator">=</span> new UpdateWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userUpdateWrapper
.like<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;h&quot;</span><span class="token punctuation">)</span>
.or<span class="token punctuation">(</span>i -<span class="token operator">&gt;</span> i.eq<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;李白&quot;</span><span class="token punctuation">)</span>.ne<span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span>, <span class="token number">20</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
int result <span class="token operator">=</span> userMapper.update<span class="token punctuation">(</span>user, userUpdateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
System.out.println<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

UPDATE user SET <span class="token assign-left variable">name</span><span class="token operator">=</span>?, <span class="token assign-left variable">age</span><span class="token operator">=</span>?, <span class="token assign-left variable">update_time</span><span class="token operator">=</span>? 
WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND name LIKE ? 
OR <span class="token punctuation">(</span> name <span class="token operator">=</span> ? AND age <span class="token operator">&lt;&gt;</span> ? <span class="token punctuation">)</span> 
</code></pre></div></blockquote> <blockquote><p>9、orderBy、orderByDesc、orderByAsc</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectListOrderBy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	queryWrapper.orderByDesc<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
SELECT id,name,age,email,create_time,update_time,deleted,version 
FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> ORDER BY <span class="token function">id</span> DESC 

</code></pre></div></blockquote> <blockquote><p>10、last
直接拼接到 sql 的最后
注意：只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectListLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	queryWrapper.last<span class="token punctuation">(</span><span class="token string">&quot;limit 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
	users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SELECT id,name,age,email,create_time,update_time,deleted,version 
FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> limit <span class="token number">1</span> 

</code></pre></div></blockquote> <blockquote><p>11、指定要查询的列</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testSelectListColumn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
QueryWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> queryWrapper <span class="token operator">=</span> new QueryWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queryWrapper.select<span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span>, <span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;age&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token function">users</span> <span class="token operator">=</span> userMapper.selectList<span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
users.forEach<span class="token punctuation">(</span>System.out::println<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
SELECT id,name,age FROM user WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> 
</code></pre></div></blockquote> <blockquote><p>12、set、setSql
最终的sql会合并 user.setAge()，以及 userUpdateWrapper.set()  和 setSql() 中 的字段</p> <div class="language-shell extra-class"><pre class="language-shell"><code>@Test
public void <span class="token function-name function">testUpdateSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
//修改值
User user <span class="token operator">=</span> new User<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user.setAge<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
//修改条件
UpdateWrapper<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> userUpdateWrapper <span class="token operator">=</span> new UpdateWrapper<span class="token operator">&lt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
userUpdateWrapper
.like<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;h&quot;</span><span class="token punctuation">)</span>
.set<span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span>, <span class="token string">&quot;老李头&quot;</span><span class="token punctuation">)</span>//除了可以查询还可以使用set设置修改的字段
.setSql<span class="token punctuation">(</span><span class="token string">&quot; email = '123@qq.com'&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//可以有子查询
int result <span class="token operator">=</span> userMapper.update<span class="token punctuation">(</span>user, userUpdateWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
UPDATE user SET <span class="token assign-left variable">age</span><span class="token operator">=</span>?, <span class="token assign-left variable">update_time</span><span class="token operator">=</span>?, <span class="token assign-left variable">name</span><span class="token operator">=</span>?, email <span class="token operator">=</span> <span class="token string">'123@qq.com'</span> WHERE <span class="token assign-left variable">deleted</span><span class="token operator">=</span><span class="token number">0</span> AND name LIKE ? 
</code></pre></div></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//代码生成器</span>
  <span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>glls<span class="token punctuation">.</span>mybatisplus</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">DbType</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span></span><span class="token class-name">AutoGenerator</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">DataSourceConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">GlobalConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">PackageConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span></span><span class="token class-name">StrategyConfig</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>generator<span class="token punctuation">.</span>config<span class="token punctuation">.</span>rules<span class="token punctuation">.</span></span><span class="token class-name">NamingStrategy</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenerateTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//创建generator对象</span>
        <span class="token class-name">AutoGenerator</span> autoGenerator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//数据源</span>
        <span class="token class-name">DataSourceConfig</span> dataSourceConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceConfig<span class="token punctuation">.</span><span class="token function">setDbType</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceConfig<span class="token punctuation">.</span><span class="token function">setDriverName</span><span class="token punctuation">(</span><span class="token string">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceConfig<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceConfig<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSourceConfig<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/mytest?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        autoGenerator<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSourceConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//全局配置</span>
        <span class="token class-name">GlobalConfig</span> globalConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GlobalConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        globalConfig<span class="token punctuation">.</span><span class="token function">setOutputDir</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;user.dir&quot;</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;/src/main/java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        globalConfig<span class="token punctuation">.</span><span class="token function">setAuthor</span><span class="token punctuation">(</span><span class="token string">&quot;admin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        globalConfig<span class="token punctuation">.</span><span class="token function">setOpen</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        globalConfig<span class="token punctuation">.</span><span class="token function">setServiceName</span><span class="token punctuation">(</span><span class="token string">&quot;%sService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        autoGenerator<span class="token punctuation">.</span><span class="token function">setGlobalConfig</span><span class="token punctuation">(</span>globalConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//包信息</span>
        <span class="token class-name">PackageConfig</span> packageConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PackageConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">&quot;com.glls&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token string">&quot;entity&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setMapper</span><span class="token punctuation">(</span><span class="token string">&quot;mapper&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setService</span><span class="token punctuation">(</span><span class="token string">&quot;service&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setServiceImpl</span><span class="token punctuation">(</span><span class="token string">&quot;service.impl&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        packageConfig<span class="token punctuation">.</span><span class="token function">setController</span><span class="token punctuation">(</span><span class="token string">&quot;controller&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        autoGenerator<span class="token punctuation">.</span><span class="token function">setPackageInfo</span><span class="token punctuation">(</span>packageConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//策略配置</span>
        <span class="token class-name">StrategyConfig</span> strategyConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategyConfig<span class="token punctuation">.</span><span class="token function">setInclude</span><span class="token punctuation">(</span><span class="token string">&quot;fruit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategyConfig<span class="token punctuation">.</span><span class="token function">setNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategyConfig<span class="token punctuation">.</span><span class="token function">setColumnNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategyConfig<span class="token punctuation">.</span><span class="token function">setEntityLombokModel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        autoGenerator<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>strategyConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//运行</span>
        autoGenerator<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
    
</code></pre></div><h1 id="第19课-spring-boot中集成-redisson"><a href="#第19课-spring-boot中集成-redisson" class="header-anchor">#</a> 第19课：Spring Boot中集成  Redisson</h1> <p>咱们之前学习的 synchronized   juc下的ReentranLock 可重入锁 CountDownLatch 闭锁  Semaphore 信号量 都是本地锁，在分布式系统下 没法用 因为 他们只能锁住当前进程，不能锁住所有服务， 我们需要一套在分布式环境下的 各种高级锁 的解决方案  ，</p> <p><code>http://www.redis.cn/commands/set.html</code>  redis 官方文档在这有介绍</p> <img src="${Pictures}/image-20200906141611182.png" alt="image-20200906141611182" style="zoom:80%;"> <p>the Redlock algorithm 链接  ---- Redisson    https://github.com/redisson/redisson/wiki/Table-of-Content</p> <h2 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h2> <p>https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0</p> <blockquote><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote> <h2 id="_2-整合步骤"><a href="#_2-整合步骤" class="header-anchor">#</a> 2.整合步骤</h2> <h3 id="_2-1引入依赖"><a href="#_2-1引入依赖" class="header-anchor">#</a> 2.1引入依赖</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>  <span class="token operator">&lt;</span><span class="token operator">!</span>--以后使用redisson 作为所有分布式锁 分布式对象等功能框架--<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.redisson<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>redisson<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.12</span>.<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/version<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_2-2配置文件"><a href="#_2-2配置文件" class="header-anchor">#</a> 2.2配置文件</h3> <p>配置方式 有很多</p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906143822087.png" alt="image-20200906143822087" style="zoom:67%;"> <blockquote><p>在这里我们先使用 程序化配置</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>package com.glls.glsc.product.config<span class="token punctuation">;</span>

<span class="token function">import</span> org.redisson.Redisson<span class="token punctuation">;</span>
<span class="token function">import</span> org.redisson.api.RedissonClient<span class="token punctuation">;</span>
<span class="token function">import</span> org.redisson.config.Config<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.context.annotation.Bean<span class="token punctuation">;</span>
<span class="token function">import</span> org.springframework.context.annotation.Configuration<span class="token punctuation">;</span>

@Configuration
public class MyRedissonConfig <span class="token punctuation">{</span>

    /**
     * 所有对Redisson 的使用 都是通过RedissonClient对象
     * */
    @Bean<span class="token punctuation">(</span>destroyMethod <span class="token operator">=</span> <span class="token string">&quot;shutdown&quot;</span><span class="token punctuation">)</span>        //指定销毁对象的方法  服务停止时 调用这个方法 进行销毁
    public RedissonClient <span class="token function-name function">redisson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        //1.创建配置    单redis节点模式
        Config config <span class="token operator">=</span> new Config<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        config.useSingleServer<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAddress<span class="token punctuation">(</span><span class="token string">&quot;redis://192.168.56.10:6379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //2.根据配置 创建RedissonClient 实例
        <span class="token builtin class-name">return</span> Redisson.create<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>	<span class="token comment"># 测试</span>
	@Autowired
    RedissonClient redissonClient<span class="token punctuation">;</span>

    @Test
    public void <span class="token function-name function">redisson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System.out.println<span class="token punctuation">(</span>redissonClient<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-分布式锁"><a href="#_3-分布式锁" class="header-anchor">#</a> 3.分布式锁</h2> <p>参考：https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</p> <h4 id="_3-1可重入锁"><a href="#_3-1可重入锁" class="header-anchor">#</a> 3.1可重入锁</h4> <p>理解： 有一个方法A ，方法A内部 调用了一个方法B ， 方法A 和 方法B 都加了锁，而且是同一把锁  如果是可重入锁，A拿到这把锁执行，然后调用B方法，B方法看A已经拿到了这把锁，那么B 直接使用这把锁，相当于B拿到A的锁直接执行  这叫可重入锁。如果设计为不可重入锁，那就糟糕了  ，A 拿到了这把锁，要调用B  结果发现B 在等待A 释放锁 ，B才能执行， A等B B等A ， 结果互相锁住了 也就是死锁，所以 所有的锁都应该设计为可重入锁 避免死锁。</p> <blockquote><p>基于Redis的Redisson分布式可重入锁<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLock.html" target="_blank" rel="noopener noreferrer"><code>RLock</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Java对象实现了<code>java.util.concurrent.locks.Lock</code>接口。同时还提供了<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html" target="_blank" rel="noopener noreferrer">异步（Async）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html" target="_blank" rel="noopener noreferrer">反射式（Reactive）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html" target="_blank" rel="noopener noreferrer">RxJava2标准<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的接口。</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>RLock lock <span class="token operator">=</span> redisson.getLock<span class="token punctuation">(</span><span class="token string">&quot;anyLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
// 最常见的使用方法
lock.lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   加锁


lock.unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_3-2测试分布式锁"><a href="#_3-2测试分布式锁" class="header-anchor">#</a> 3.2测试分布式锁</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>比如  商品服务  运行在10000端口  复制出来两份  设置运行端口为 <span class="token number">10001</span>    <span class="token number">10002</span>
</code></pre></div><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906162742320.png" alt="image-20200906162742320"></p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906162859963.png" alt="image-20200906162859963"></p> <p>利用不同的端口，启动这多个服务，就会有多个进程 ，提供同一个服务功能，此时  用本地锁  就不能同时锁住这多个进程了</p> <div class="language-shell extra-class"><pre class="language-shell"><code>  @ResponseBody
    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
    public String  hello<span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>

        ReentrantLock reentrantLock <span class="token operator">=</span> new ReentrantLock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        reentrantLock.lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        try<span class="token punctuation">{</span>
            System.out.println<span class="token punctuation">(</span><span class="token string">&quot;加锁成功 执行业务...&quot;</span>+Thread.currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span>.getId<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            TimeUnit.<span class="token environment constant">SECONDS</span>.sleep<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>
            System.out.println<span class="token punctuation">(</span><span class="token string">&quot;释放锁...&quot;</span>+Thread.currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span>.getId<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            reentrantLock.unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 解锁
        <span class="token punctuation">}</span>
        <span class="token builtin class-name">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906163120040.png" alt="image-20200906163120040"></p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200906163137461.png" alt="image-20200906163137461"></p> <blockquote><p>两个请求 能同时访问服务，咱们需要的是 一把锁 锁住多个进程执行的这段代码  保证 只能有一个线程得到锁 执行</p> <p>使用 redisson 分布式锁 轻松实现</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>  @ResponseBody
    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
    public String  hello<span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>

        // <span class="token number">1</span>.获取一把锁 ，只要锁名一样  就是同一把锁
        RLock lock <span class="token operator">=</span> redisson.getLock<span class="token punctuation">(</span><span class="token string">&quot;my-lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //2.加锁
        lock.lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   // 阻塞式  等待 默认加锁30秒  如果当前线程拿不到锁 就一直在这里等待  直到当前线程能拿到锁  才能往下执行
        // 锁的自动续期 如果业务超长 运行期间自动给锁续上30秒 不用担心业务时间长  锁自动过期被删掉
        // 加锁的业务只要运行完成 就不会给当前锁续期 即使不手动解锁 锁默认30秒以后自动删除
        try<span class="token punctuation">{</span>
            System.out.println<span class="token punctuation">(</span><span class="token string">&quot;加锁成功 执行业务...&quot;</span>+Thread.currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span>.getId<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            TimeUnit.<span class="token environment constant">SECONDS</span>.sleep<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>
            System.out.println<span class="token punctuation">(</span><span class="token string">&quot;释放锁...&quot;</span>+Thread.currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span>.getId<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            lock.unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 解锁
        <span class="token punctuation">}</span>

        <span class="token builtin class-name">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意 redisson 提供的锁 底层 还是   占坑思想  而且 这个坑默认30秒  也就是  setnx  命令  如果一个key不存在就设置进去 并设定默认30秒有效期，如果30秒内 业务逻辑没走完 自动延长坑的时间，如果占坑线程由于某种原因 没有释放锁  比如 服务中断 ，redisson  会自动 释放锁。  避免死锁问题</p></blockquote> <p>测试运行  发现这个锁 能满足需求</p> <blockquote><p><strong>公平锁</strong>  Fair Lock                  RLock fairLock = redisson.getFairLock(&quot;anyLock&quot;);     了解</p> <p>基于Redis的Redisson分布式可重入公平锁也是实现了<code>java.util.concurrent.locks.Lock</code>接口的一种<code>RLock</code>对象。同时还提供了<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html" target="_blank" rel="noopener noreferrer">异步（Async）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html" target="_blank" rel="noopener noreferrer">反射式（Reactive）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html" target="_blank" rel="noopener noreferrer">RxJava2标准<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么 后面的线程会等待至少25秒。</p> <p>简单理解 就是 排着队抢锁 排队靠前的先拿到锁   默认 是非公平锁    就是所有线程 不排队 谁都有可能先抢到</p></blockquote> <blockquote><p><strong>读写锁</strong> ReadWriteLock       RReadWriteLock rwlock = redisson.getReadWriteLock(&quot;anyRWLock&quot;);</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 最常见的使用方法</span>
rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或</span>
rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>业务要读的时候 就加 读锁</p> <p>业务要修改的时候  就加 写锁</p> <p>A在修改数据    B要读取数据   B要等待A把锁释放了  才能读取数据，如果都是并发读数据  互不影响 ，并发写 会竞争锁   ，只要写锁存在    读锁就得等待</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
     * 读写锁的好处   能够保证 一定读到最新数据
     *  写锁 是一个排他锁 （互斥锁）
     *  读锁 是一个共享锁  加了跟没加一样
     *  只要写锁存在  就必须等待
     *  读+ 读   相当于无锁  并发读   不会等待 会在redis 中记录当前的所有线程的读锁
     *  写+读     等待写释放
     *  写+写    阻塞模式
     *  读+写    正在读的时候   写也需要等待
     * */


    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/write&quot;</span><span class="token punctuation">)</span>
    @ResponseBody
    public String <span class="token function-name function">writeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        RReadWriteLock lock <span class="token operator">=</span> redisson.getReadWriteLock<span class="token punctuation">(</span><span class="token string">&quot;rw-lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        String <span class="token assign-left variable">s</span><span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>

        RLock rLock <span class="token operator">=</span> lock.writeLock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        try <span class="token punctuation">{</span>
            // 改数据  加写锁    读数据 加 读锁
            rLock.lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s <span class="token operator">=</span> UUID.randomUUID<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            TimeUnit.<span class="token environment constant">SECONDS</span>.sleep<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            redisTemplate.opsForValue<span class="token punctuation">(</span><span class="token punctuation">)</span>.set<span class="token punctuation">(</span><span class="token string">&quot;writeValue&quot;</span>,s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>
            rLock.unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token builtin class-name">return</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/read&quot;</span><span class="token punctuation">)</span>
    @ResponseBody
    public String <span class="token function-name function">readValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        RReadWriteLock lock <span class="token operator">=</span> redisson.getReadWriteLock<span class="token punctuation">(</span><span class="token string">&quot;rw-lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        RLock rLock <span class="token operator">=</span> lock.readLock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String <span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
        try<span class="token punctuation">{</span>
            rLock.lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 加 读锁
            value <span class="token operator">=</span> redisTemplate.opsForValue<span class="token punctuation">(</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token string">&quot;writeValue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>finally <span class="token punctuation">{</span>
            rLock.unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>


        <span class="token builtin class-name">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>**闭锁 ** CountDownLatch</p> <p>基于Redisson的Redisson分布式闭锁（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RCountDownLatch.html" target="_blank" rel="noopener noreferrer">CountDownLatch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p> <div class="language- extra-class"><pre class="language-text"><code>RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.trySetCount(1);
latch.await();

// 在其他线程或其他JVM里
RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.countDown();
</code></pre></div></blockquote> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">/**
     * 放假 锁学校大门
     * 
     * 5个班全部走完  我们可以锁大门
     * */</span>

<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/lockDoor&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseBody</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span>  <span class="token function">lockDoor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">RCountDownLatch</span> door <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getCountDownLatch</span><span class="token punctuation">(</span><span class="token string">&quot;door&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        door<span class="token punctuation">.</span><span class="token function">trySetCount</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 5个班</span>

        door<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  等待闭锁都完成</span>

        <span class="token keyword">return</span> <span class="token string">&quot;放假了&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/gogogo/{id}&quot;</span><span class="token punctuation">)</span>
	<span class="token annotation punctuation">@ResponseBody</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">gogogo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token class-name">RCountDownLatch</span> door <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getCountDownLatch</span><span class="token punctuation">(</span><span class="token string">&quot;door&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        door<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计数减一</span>

        <span class="token keyword">return</span> id<span class="token operator">+</span><span class="token string">&quot;班的人都走了&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>信号量  Semaphore</p> <p>基于Redis的Redisson的分布式信号量（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html" target="_blank" rel="noopener noreferrer">Semaphore<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）Java对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html" target="_blank" rel="noopener noreferrer">异步（Async）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html" target="_blank" rel="noopener noreferrer">反射式（Reactive）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html" target="_blank" rel="noopener noreferrer">RxJava2标准<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的接口</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>/**
     * 车位停车
     * <span class="token number">3</span>车位

     *  利用信号量的特性   可以进行   限流操作
     *  比如 系统只能供10000 个线程访问  ，就可以分配10000 个 信号量
     *
     * */
    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/park&quot;</span><span class="token punctuation">)</span>
    @ResponseBody
    public String park<span class="token punctuation">(</span><span class="token punctuation">)</span> throws InterruptedException <span class="token punctuation">{</span>
        //先在 redis设置键值：   <span class="token builtin class-name">set</span> park <span class="token number">3</span>
        RSemaphore park <span class="token operator">=</span> redisson.getSemaphore<span class="token punctuation">(</span><span class="token string">&quot;park&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       // park.acquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 获取一个信号 获取一个值 占一个车位    可以执行三次  车位占完  就没法继续往下执行了   需要释放

        boolean b <span class="token operator">=</span> park.tryAcquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   // 尝试 获取信号量   获取到返回 <span class="token boolean">true</span>  获取不到  返回false
		// 限流操作
		if<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>
			// 车位够  执行业务
		<span class="token punctuation">}</span>else<span class="token punctuation">{</span>
		   // 车位不够  执行限流 
		   
		<span class="token punctuation">}</span>
        <span class="token builtin class-name">return</span> <span class="token string">&quot;ok&quot;</span> + b<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    @GetMapping<span class="token punctuation">(</span><span class="token string">&quot;/go&quot;</span><span class="token punctuation">)</span>
    @ResponseBody
    public String <span class="token function-name function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        RSemaphore park <span class="token operator">=</span> redisson.getSemaphore<span class="token punctuation">(</span><span class="token string">&quot;park&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        park.release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   // 释放一个车位

        <span class="token builtin class-name">return</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>总结：分布式锁使用 redisson解决</p> <h1 id="第20课-spring-boot整合jsp"><a href="#第20课-spring-boot整合jsp" class="header-anchor">#</a> 第20课：Spring Boot整合jsp</h1> <h2 id="_1-导入依赖"><a href="#_1-导入依赖" class="header-anchor">#</a> 1.导入依赖</h2> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">&lt;</span><span class="token operator">!</span>--        JSP核心引擎依赖--<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.apache.tomcat.embed<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>tomcat-embed-jasper<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>--        JSTL--<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>javax.servlet<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>jstl<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre></div><h2 id="_2-配置视图解析器"><a href="#_2-配置视图解析器" class="header-anchor">#</a> 2.配置视图解析器</h2> <div class="language-shell extra-class"><pre class="language-shell"><code>spring:
  mvc:
    <span class="token comment"># 视图的前缀和后缀</span>
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
</code></pre></div><h2 id="_3-创建webapp目录等"><a href="#_3-创建webapp目录等" class="header-anchor">#</a> 3.创建webapp目录等</h2> <blockquote><p>在src--main下创建webapp目录   注意 和java  resources 同级的，在webapp 下 创建  如图所示的文件</p> <p>另外 需要注意 直接创建的 webapp 是不能在其下 创建jsp 文件的  调整其工程目录结构  如下图</p></blockquote> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200927154729866.png" alt="image-20200927154729866"></p> <p>调整后</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200927155058975.png" alt="image-20200927155058975"></p> <p>4.创建controller 进行 页面跳转</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JspController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/index&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>
        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;index&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>5.资源拷贝插件</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 如果 找不到 对应的 jsp  报404   可能是 没有把webapp 目录打包到部署文件 使用下面的资源拷贝插件 可以解决   </span>
<span class="token comment"># 注意   改完配置文件之后  刷新 maven   reimport   加载pom 文件 </span>

<span class="token operator">&lt;</span>resources<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>resource<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>directory<span class="token operator">&gt;</span>src/main/java<span class="token operator">&lt;</span>/directory<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>includes<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>include<span class="token operator">&gt;</span>**/*.xml<span class="token operator">&lt;</span>/include<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>/includes<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/resource<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>resource<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>directory<span class="token operator">&gt;</span>src/main/resources<span class="token operator">&lt;</span>/directory<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>includes<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>include<span class="token operator">&gt;</span>**/*.*<span class="token operator">&lt;</span>/include<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>/includes<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/resource<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 打包时将jsp文件拷贝到META-INF目录下 --<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>resource<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">!</span>-- 指定resources插件处理哪个目录下的资源文件 --<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>directory<span class="token operator">&gt;</span>src/main/webapp<span class="token operator">&lt;</span>/directory<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">!</span>--注意此次必须要放在此目录下才能被访问到 --<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>targetPath<span class="token operator">&gt;</span>META-INF/resources<span class="token operator">&lt;</span>/targetPath<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>includes<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>include<span class="token operator">&gt;</span>**/*.*<span class="token operator">&lt;</span>/include<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>/includes<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>/resource<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>/resources<span class="token operator">&gt;</span>
</code></pre></div><h1 id="第21课-使用knife4j代替swagger"><a href="#第21课-使用knife4j代替swagger" class="header-anchor">#</a> 第21课：使用Knife4j代替Swagger</h1> <blockquote><p><code>Knife4j</code>的前身是<code>swagger-bootstrap-ui</code>,前身<code>swagger-bootstrap-ui</code>是一个纯<code>swagger-ui</code>的<code>ui</code>皮肤项目</p></blockquote> <blockquote><p>快速开始</p></blockquote> <p><a href="https://doc.xiaominfo.com/knife4j/documentation/get_start.html" target="_blank" rel="noopener noreferrer">1.6 快速开始 | knife4j (xiaominfo.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="第22课-spring-boot搭建实际项目开发中的架构"><a href="#第22课-spring-boot搭建实际项目开发中的架构" class="header-anchor">#</a> 第22课：Spring Boot搭建实际项目开发中的架构</h1> <p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p> <p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p> <p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p> <p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p> <p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20210517085816727.png" alt="image-20210517085816727"></p> <h2 id="_1-统一的数据封装"><a href="#_1-统一的数据封装" class="header-anchor">#</a> 1. 统一的数据封装</h2> <p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 统一返回对象
 * @author  glls
 * @param &lt;T&gt;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> code<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 若没有数据返回，可以人为指定状态码和提示信息
     * @param code
     * @param msg
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token class-name">String</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 有数据返回时，状态码为0，默认提示信息为：操作成功！
     * @param data
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">&quot;操作成功！&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 有数据返回，状态码为0，人为指定提示信息
     * @param data
     * @param msg
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/**
     * 使用自定义异常作为参数传递状态码和提示信息
     * @param msgEnum
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token class-name">BusinessMsgEnum</span> msgEnum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> msgEnum<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msgEnum<span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省去get和set方法</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p> <h2 id="_2-json的处理"><a href="#_2-json的处理" class="header-anchor">#</a> 2. json的处理</h2> <p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * jacksonConfig
 * @author  glls
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@Primary</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">ObjectMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ObjectMapper</span> <span class="token function">jacksonObjectMapper</span><span class="token punctuation">(</span><span class="token class-name">Jackson2ObjectMapperBuilder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ObjectMapper</span> objectMapper <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">createXmlMapper</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectMapper<span class="token punctuation">.</span><span class="token function">getSerializerProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNullValueSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JsonSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">JsonGenerator</span> jsonGenerator<span class="token punctuation">,</span> <span class="token class-name">SerializerProvider</span> serializerProvider<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
                jsonGenerator<span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> objectMapper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p> <h2 id="_3-swagger2在线可调式接口"><a href="#_3-swagger2在线可调式接口" class="header-anchor">#</a> 3. swagger2在线可调式接口</h2> <p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * swagger配置
 * @author  glls
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableSwagger2</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span><span class="token constant">SWAGGER_2</span><span class="token punctuation">)</span>
                <span class="token comment">// 指定构建api文档的详细信息的方法：apiInfo()</span>
                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口</span>
                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span><span class="token class-name">RequestHandlerSelectors</span><span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">&quot;com.javanewbie.course18.controller&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 构建api文档的详细信息
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">ApiInfo</span> <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 设置页面标题</span>
                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">&quot;Spring Boot搭建实际项目中开发的架构&quot;</span><span class="token punctuation">)</span>
                <span class="token comment">// 设置接口描述</span>
                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">&quot;跟武哥一起学Spring Boot第18课&quot;</span><span class="token punctuation">)</span>
                <span class="token comment">// 设置联系方式</span>
                <span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span><span class="token string">&quot;zs，&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;微信公众号：程序员私房菜&quot;</span><span class="token punctuation">)</span>
                <span class="token comment">// 设置版本</span>
                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">&quot;1.0&quot;</span><span class="token punctuation">)</span>
                <span class="token comment">// 构建</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户信息接口&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/getUser/{id}&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;根据用户唯一标识获取用户信息&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;用户唯一标识&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token string">&quot;zs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JsonResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p> <h2 id="_4-持久层集成"><a href="#_4-持久层集成" class="header-anchor">#</a> 4. 持久层集成</h2> <p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token comment"># 服务端口号</span>
<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>

<span class="token comment"># 数据库地址</span>
<span class="token key atrule">datasource</span><span class="token punctuation">:</span>
  <span class="token key atrule">url</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span>3306/blog_test

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span> <span class="token comment"># 数据库配置</span>
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>datasource.url<span class="token punctuation">}</span><span class="token punctuation">?</span>useSSL=false<span class="token important">&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">hikari</span><span class="token punctuation">:</span>
      <span class="token key atrule">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment"># 最大连接池数</span>
      <span class="token key atrule">max-lifetime</span><span class="token punctuation">:</span> <span class="token number">1770000</span>

<span class="token key atrule">mybatis</span><span class="token punctuation">:</span>
  <span class="token comment"># 指定别名设置的包为所有entity</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.javanewbie.course18.entity
  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>
    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 驼峰命名规范</span>
  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> <span class="token comment"># mapper映射文件位置</span>
    <span class="token punctuation">-</span> classpath<span class="token punctuation">:</span>mapper/<span class="token important">*.xml</span>
</code></pre></div><p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id}&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Results</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>property <span class="token operator">=</span> <span class="token string">&quot;username&quot;</span><span class="token punctuation">,</span> column <span class="token operator">=</span> <span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>property <span class="token operator">=</span> <span class="token string">&quot;password&quot;</span><span class="token punctuation">,</span> column <span class="token operator">=</span> <span class="token string">&quot;password&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">&quot;select * from user where id = #{id} and user_name=#{name}&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">User</span> <span class="token function">getUserByIdAndName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">&quot;select * from user&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code>@MapperScan(&quot;com.javanewbie.course18.dao&quot;)</code></p> <h2 id="_5-拦截器"><a href="#_5-拦截器" class="header-anchor">#</a> 5. 拦截器</h2> <p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">MyInterceptor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;执行方法之前执行(Controller方法调用之前)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">ModelAndView</span> modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后将自定义的拦截器加入到拦截器配置中。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptorConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 拦截所有url</span>
                <span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span>
                <span class="token comment">// 放行swagger</span>
                <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/swagger-resources/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p> <blockquote><p>classpath:/static<br>
classpath:/public<br>
classpath:/resources<br>
classpath:/META-INF/resources</p></blockquote> <p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p> <p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p> <h2 id="_6-全局异常处理"><a href="#_6-全局异常处理" class="header-anchor">#</a> 6. 全局异常处理</h2> <p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BusinessMsgEnum</span> <span class="token punctuation">{</span>
    <span class="token comment">/** 参数异常 */</span>
    <span class="token function">PARMETER_EXCEPTION</span><span class="token punctuation">(</span><span class="token string">&quot;102&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;参数异常!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/** 等待超时 */</span>
    <span class="token function">SERVICE_TIME_OUT</span><span class="token punctuation">(</span><span class="token string">&quot;103&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;服务调用超时！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/** 参数过大 */</span>
    <span class="token function">PARMETER_BIG_EXCEPTION</span><span class="token punctuation">(</span><span class="token string">&quot;102&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;输入的图片数量不能超过50张!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/** 500 : 发生异常 */</span>
    <span class="token function">UNEXPECTED_EXCEPTION</span><span class="token punctuation">(</span><span class="token string">&quot;500&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;系统发生异常，请联系管理员！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 消息码
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> code<span class="token punctuation">;</span>
    <span class="token comment">/**
     * 消息内容
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">BusinessMsgEnum</span><span class="token punctuation">(</span><span class="token class-name">String</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@ControllerAdvice</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">GlobalExceptionHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 拦截业务异常，返回业务异常信息
     * @param ex
     * @return
     */</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BusinessErrorException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseStatus</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">INTERNAL_SERVER_ERROR</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span> <span class="token function">handleBusinessError</span><span class="token punctuation">(</span><span class="token class-name">BusinessErrorException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> code <span class="token operator">=</span> ex<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 空指针异常
     * @param ex NullPointerException
     * @return
     */</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">NullPointerException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseStatus</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">INTERNAL_SERVER_ERROR</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span> <span class="token function">handleTypeMismatchException</span><span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;空指针异常，{}&quot;</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token string">&quot;500&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;空指针异常了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 系统异常 预期以外异常
     * @param ex
     * @return
     */</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseStatus</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">INTERNAL_SERVER_ERROR</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">JsonResult</span> <span class="token function">handleUnexpectedServer</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;系统异常：&quot;</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JsonResult</span><span class="token punctuation">(</span><span class="token class-name">BusinessMsgEnum</span><span class="token punctuation">.</span><span class="token constant">UNEXPECTED_EXCEPTION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。
在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p> <h2 id="_7-总结"><a href="#_7-总结" class="header-anchor">#</a> 7. 总结</h2> <p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-springboot是什么" class="sidebar-link reco-side-_1-springboot是什么" data-v-b57cc07c>1.SpringBoot是什么</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-为什么学习spring-boot" class="sidebar-link reco-side-_2-为什么学习spring-boot" data-v-b57cc07c>2.为什么学习Spring Boot</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-从spring官方来看" class="sidebar-link reco-side-_2-1-从spring官方来看" data-v-b57cc07c>2.1 从Spring官方来看</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-从spring-boot的优点来看" class="sidebar-link reco-side-_2-2-从spring-boot的优点来看" data-v-b57cc07c>2.2 从Spring Boot的优点来看</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-3-从未来发展的趋势来看" class="sidebar-link reco-side-_2-3-从未来发展的趋势来看" data-v-b57cc07c>2.3 从未来发展的趋势来看</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-本课程能学到什么" class="sidebar-link reco-side-_3-本课程能学到什么" data-v-b57cc07c>3. 本课程能学到什么</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-本课程开发环境和插件" class="sidebar-link reco-side-_4-本课程开发环境和插件" data-v-b57cc07c>4.本课程开发环境和插件</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-课程目录" class="sidebar-link reco-side-_5-课程目录" data-v-b57cc07c>5. 课程目录</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-jdk-的配置" class="sidebar-link reco-side-_1-jdk-的配置" data-v-b57cc07c>1. jdk 的配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-spring-boot-工程的构建" class="sidebar-link reco-side-_2-spring-boot-工程的构建" data-v-b57cc07c>2. Spring Boot 工程的构建</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-idea-快速构建" class="sidebar-link reco-side-_2-1-idea-快速构建" data-v-b57cc07c>2.1 IDEA 快速构建</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-官方构建" class="sidebar-link reco-side-_2-2-官方构建" data-v-b57cc07c>2.2 官方构建</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-3-maven配置" class="sidebar-link reco-side-_2-3-maven配置" data-v-b57cc07c>2.3 maven配置</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-4-编码配置" class="sidebar-link reco-side-_2-4-编码配置" data-v-b57cc07c>2.4 编码配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-spring-boot-项目工程结构" class="sidebar-link reco-side-_3-spring-boot-项目工程结构" data-v-b57cc07c>3. Spring Boot 项目工程结构</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结" class="sidebar-link reco-side-_4-总结" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-spring-boot-默认对json的处理" class="sidebar-link reco-side-_1-spring-boot-默认对json的处理" data-v-b57cc07c>1. Spring Boot 默认对Json的处理</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-1-创建-user-实体类" class="sidebar-link reco-side-_1-1-创建-user-实体类" data-v-b57cc07c>1.1 创建 User 实体类</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-2-创建controller类" class="sidebar-link reco-side-_1-2-创建controller类" data-v-b57cc07c>1.2 创建Controller类</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-3-测试不同数据类型返回的json" class="sidebar-link reco-side-_1-3-测试不同数据类型返回的json" data-v-b57cc07c>1.3 测试不同数据类型返回的json</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-4-jackson-中对null的处理" class="sidebar-link reco-side-_1-4-jackson-中对null的处理" data-v-b57cc07c>1.4 jackson 中对null的处理</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-使用阿里巴巴fastjson的设置" class="sidebar-link reco-side-_2-使用阿里巴巴fastjson的设置" data-v-b57cc07c>2.使用阿里巴巴FastJson的设置</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-jackson-和-fastjson-的对比" class="sidebar-link reco-side-_2-1-jackson-和-fastjson-的对比" data-v-b57cc07c>2.1 jackson 和 fastJson 的对比</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-fastjson依赖导入" class="sidebar-link reco-side-_2-2-fastjson依赖导入" data-v-b57cc07c>2.2 fastJson依赖导入</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-使用-fastjson-处理-null" class="sidebar-link reco-side-_2-2-使用-fastjson-处理-null" data-v-b57cc07c>2.2 使用 fastJson 处理 null</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-封装统一返回的数据结构" class="sidebar-link reco-side-_3-封装统一返回的数据结构" data-v-b57cc07c>3. 封装统一返回的数据结构</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-定义统一的-json-结构" class="sidebar-link reco-side-_3-1-定义统一的-json-结构" data-v-b57cc07c>3.1 定义统一的 json 结构</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-修改-controller-中的返回值类型及测试" class="sidebar-link reco-side-_3-2-修改-controller-中的返回值类型及测试" data-v-b57cc07c>3.2 修改 Controller 中的返回值类型及测试</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结-2" class="sidebar-link reco-side-_4-总结-2" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-slf4j-介绍" class="sidebar-link reco-side-_1-slf4j-介绍" data-v-b57cc07c>1. slf4j 介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-application-yml-中对日志的配置" class="sidebar-link reco-side-_2-application-yml-中对日志的配置" data-v-b57cc07c>2. application.yml 中对日志的配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-logback-xml-配置文件解析" class="sidebar-link reco-side-_3-logback-xml-配置文件解析" data-v-b57cc07c>3. logback.xml 配置文件解析</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-定义日志输出格式和存储路径" class="sidebar-link reco-side-_3-1-定义日志输出格式和存储路径" data-v-b57cc07c>3.1 定义日志输出格式和存储路径</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-定义控制台输出" class="sidebar-link reco-side-_3-2-定义控制台输出" data-v-b57cc07c>3.2 定义控制台输出</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-3-定义日志文件的相关参数" class="sidebar-link reco-side-_3-3-定义日志文件的相关参数" data-v-b57cc07c>3.3 定义日志文件的相关参数</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-4-定义日志输出级别" class="sidebar-link reco-side-_3-4-定义日志输出级别" data-v-b57cc07c>3.4 定义日志输出级别</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-使用logger在项目中打印日志" class="sidebar-link reco-side-_4-使用logger在项目中打印日志" data-v-b57cc07c>4. 使用Logger在项目中打印日志</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-总结" class="sidebar-link reco-side-_5-总结" data-v-b57cc07c>5. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-少量配置信息的情形" class="sidebar-link reco-side-_1-少量配置信息的情形" data-v-b57cc07c>1. 少量配置信息的情形</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-多个配置信息的情形" class="sidebar-link reco-side-_2-多个配置信息的情形" data-v-b57cc07c>2.多个配置信息的情形</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-指定项目配置文件" class="sidebar-link reco-side-_3-指定项目配置文件" data-v-b57cc07c>3. 指定项目配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结-3" class="sidebar-link reco-side-_4-总结-3" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-restcontroller" class="sidebar-link reco-side-_1-restcontroller" data-v-b57cc07c>1. @RestController</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-requestmapping" class="sidebar-link reco-side-_2-requestmapping" data-v-b57cc07c>2. @RequestMapping</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-pathvariable" class="sidebar-link reco-side-_3-pathvariable" data-v-b57cc07c>3. @PathVariable</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-requestparam" class="sidebar-link reco-side-_4-requestparam" data-v-b57cc07c>4. @RequestParam</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-requestbody" class="sidebar-link reco-side-_5-requestbody" data-v-b57cc07c>5. @RequestBody</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_6-总结" class="sidebar-link reco-side-_6-总结" data-v-b57cc07c>6. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-swagger-简介" class="sidebar-link reco-side-_1-swagger-简介" data-v-b57cc07c>1. Swagger 简介</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-1-解决的问题" class="sidebar-link reco-side-_1-1-解决的问题" data-v-b57cc07c>1.1 解决的问题</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-2-swagger-官方" class="sidebar-link reco-side-_1-2-swagger-官方" data-v-b57cc07c>1.2 Swagger 官方</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-swagger2-的-maven-依赖" class="sidebar-link reco-side-_2-swagger2-的-maven-依赖" data-v-b57cc07c>2. Swagger2 的 maven 依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-swagger2-的配置" class="sidebar-link reco-side-_3-swagger2-的配置" data-v-b57cc07c>3. Swagger2 的配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-swagger2-的使用" class="sidebar-link reco-side-_4-swagger2-的使用" data-v-b57cc07c>4. Swagger2 的使用</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-1-实体类注解" class="sidebar-link reco-side-_4-1-实体类注解" data-v-b57cc07c>4.1 实体类注解</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-2-controller-类中相关注解" class="sidebar-link reco-side-_4-2-controller-类中相关注解" data-v-b57cc07c>4.2 Controller 类中相关注解</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-3把swagger2的api接口导入postman" class="sidebar-link reco-side-_4-3把swagger2的api接口导入postman" data-v-b57cc07c>4.3把Swagger2的API接口导入Postman</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-4-配置swagger-之后-访问-swagger-ui-html-出现-404-解决方案" class="sidebar-link reco-side-_4-4-配置swagger-之后-访问-swagger-ui-html-出现-404-解决方案" data-v-b57cc07c>4.4  配置swagger 之后 访问 swagger-ui.html 出现  404   解决方案</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-总结-2" class="sidebar-link reco-side-_5-总结-2" data-v-b57cc07c>5. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-thymeleaf-介绍" class="sidebar-link reco-side-_1-thymeleaf-介绍" data-v-b57cc07c>1.Thymeleaf 介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-依赖导入" class="sidebar-link reco-side-_2-依赖导入" data-v-b57cc07c>2. 依赖导入</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-thymeleaf相关配置" class="sidebar-link reco-side-_3-thymeleaf相关配置" data-v-b57cc07c>3. Thymeleaf相关配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-thymeleaf-的使用" class="sidebar-link reco-side-_4-thymeleaf-的使用" data-v-b57cc07c>4. Thymeleaf 的使用</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-1-访问静态页面" class="sidebar-link reco-side-_4-1-访问静态页面" data-v-b57cc07c>4.1 访问静态页面</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-2-thymeleaf-中处理对象" class="sidebar-link reco-side-_4-2-thymeleaf-中处理对象" data-v-b57cc07c>4.2 Thymeleaf 中处理对象</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-3-thymeleaf-中处理-list" class="sidebar-link reco-side-_4-3-thymeleaf-中处理-list" data-v-b57cc07c>4.3 Thymeleaf 中处理 List</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-4-其他常用-thymeleaf-操作" class="sidebar-link reco-side-_4-4-其他常用-thymeleaf-操作" data-v-b57cc07c>4.4 其他常用 thymeleaf 操作</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-总结-3" class="sidebar-link reco-side-_5-总结-3" data-v-b57cc07c>5. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-定义返回的统一-json-结构" class="sidebar-link reco-side-_1-定义返回的统一-json-结构" data-v-b57cc07c>1. 定义返回的统一 json 结构</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-处理系统异常" class="sidebar-link reco-side-_2-处理系统异常" data-v-b57cc07c>2. 处理系统异常</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-处理参数缺失异常" class="sidebar-link reco-side-_2-1-处理参数缺失异常" data-v-b57cc07c>2.1 处理参数缺失异常</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-处理空指针异常" class="sidebar-link reco-side-_2-2-处理空指针异常" data-v-b57cc07c>2.2 处理空指针异常</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-3-一劳永逸" class="sidebar-link reco-side-_2-3-一劳永逸" data-v-b57cc07c>2.3 一劳永逸？</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-拦截自定义异常" class="sidebar-link reco-side-_3-拦截自定义异常" data-v-b57cc07c>3. 拦截自定义异常</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-定义异常信息" class="sidebar-link reco-side-_3-1-定义异常信息" data-v-b57cc07c>3.1 定义异常信息</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-拦截自定义异常" class="sidebar-link reco-side-_3-2-拦截自定义异常" data-v-b57cc07c>3.2 拦截自定义异常</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结-4" class="sidebar-link reco-side-_4-总结-4" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-什么是aop" class="sidebar-link reco-side-_1-什么是aop" data-v-b57cc07c>1. 什么是AOP</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-spring-boot-中的-aop-处理" class="sidebar-link reco-side-_2-spring-boot-中的-aop-处理" data-v-b57cc07c>2. Spring Boot 中的 AOP 处理</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-aop-依赖" class="sidebar-link reco-side-_2-1-aop-依赖" data-v-b57cc07c>2.1 AOP 依赖</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-实现-aop-切面" class="sidebar-link reco-side-_2-2-实现-aop-切面" data-v-b57cc07c>2.2 实现 AOP 切面</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-总结" class="sidebar-link reco-side-_3-总结" data-v-b57cc07c>3. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-mybatis-介绍" class="sidebar-link reco-side-_1-mybatis-介绍" data-v-b57cc07c>1. MyBatis 介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-mybatis-的配置" class="sidebar-link reco-side-_2-mybatis-的配置" data-v-b57cc07c>2. MyBatis 的配置</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-依赖导入" class="sidebar-link reco-side-_2-1-依赖导入" data-v-b57cc07c>2.1 依赖导入</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-配置文件" class="sidebar-link reco-side-_2-2-配置文件" data-v-b57cc07c>2.2 配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-基于-xml-的整合" class="sidebar-link reco-side-_3-基于-xml-的整合" data-v-b57cc07c>3. 基于 xml 的整合</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-基于注解的整合" class="sidebar-link reco-side-_4-基于注解的整合" data-v-b57cc07c>4. 基于注解的整合</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-总结-4" class="sidebar-link reco-side-_5-总结-4" data-v-b57cc07c>5. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-事务相关" class="sidebar-link reco-side-_1-事务相关" data-v-b57cc07c>1. 事务相关</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-spring-boot-事务配置" class="sidebar-link reco-side-_2-spring-boot-事务配置" data-v-b57cc07c>2. Spring Boot 事务配置</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-依赖导入-2" class="sidebar-link reco-side-_2-1-依赖导入-2" data-v-b57cc07c>2.1 依赖导入</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-事务的测试" class="sidebar-link reco-side-_2-2-事务的测试" data-v-b57cc07c>2.2 事务的测试</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-常见问题总结" class="sidebar-link reco-side-_3-常见问题总结" data-v-b57cc07c>3. 常见问题总结</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-异常并没有被-捕获-到" class="sidebar-link reco-side-_3-1-异常并没有被-捕获-到" data-v-b57cc07c>3.1 异常并没有被 ”捕获“ 到</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-异常被-吃-掉" class="sidebar-link reco-side-_3-2-异常被-吃-掉" data-v-b57cc07c>3.2 异常被 ”吃“ 掉</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-3-事务的范围" class="sidebar-link reco-side-_3-3-事务的范围" data-v-b57cc07c>3.3 事务的范围</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结-5" class="sidebar-link reco-side-_4-总结-5" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-监听器介绍" class="sidebar-link reco-side-_1-监听器介绍" data-v-b57cc07c>1. 监听器介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-spring-boot中监听器的使用" class="sidebar-link reco-side-_2-spring-boot中监听器的使用" data-v-b57cc07c>2. Spring Boot中监听器的使用</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-监听servlet上下文对象" class="sidebar-link reco-side-_2-1-监听servlet上下文对象" data-v-b57cc07c>2.1 监听Servlet上下文对象</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-监听http会话-session对象" class="sidebar-link reco-side-_2-2-监听http会话-session对象" data-v-b57cc07c>2.2 监听HTTP会话 Session对象</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-3-监听客户端请求servlet-request对象" class="sidebar-link reco-side-_2-3-监听客户端请求servlet-request对象" data-v-b57cc07c>2.3 监听客户端请求Servlet Request对象</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-spring-boot中自定义事件监听" class="sidebar-link reco-side-_3-spring-boot中自定义事件监听" data-v-b57cc07c>3. Spring Boot中自定义事件监听</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-自定义事件" class="sidebar-link reco-side-_3-1-自定义事件" data-v-b57cc07c>3.1 自定义事件</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-自定义监听器" class="sidebar-link reco-side-_3-2-自定义监听器" data-v-b57cc07c>3.2 自定义监听器</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-总结-6" class="sidebar-link reco-side-_4-总结-6" data-v-b57cc07c>4. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-拦截器的快速使用" class="sidebar-link reco-side-_1-拦截器的快速使用" data-v-b57cc07c>1. 拦截器的快速使用</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-1-定义拦截器" class="sidebar-link reco-side-_1-1-定义拦截器" data-v-b57cc07c>1.1 定义拦截器</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-2-配置拦截器" class="sidebar-link reco-side-_1-2-配置拦截器" data-v-b57cc07c>1.2 配置拦截器</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-3-解决静态资源被拦截问题" class="sidebar-link reco-side-_1-3-解决静态资源被拦截问题" data-v-b57cc07c>1.3 解决静态资源被拦截问题</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-拦截器使用实例" class="sidebar-link reco-side-_2-拦截器使用实例" data-v-b57cc07c>2. 拦截器使用实例</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-判断用户有没有登录" class="sidebar-link reco-side-_2-1-判断用户有没有登录" data-v-b57cc07c>2.1 判断用户有没有登录</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-取消拦截操作" class="sidebar-link reco-side-_2-2-取消拦截操作" data-v-b57cc07c>2.2 取消拦截操作</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-总结-2" class="sidebar-link reco-side-_3-总结-2" data-v-b57cc07c>3. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-redis-介绍" class="sidebar-link reco-side-_1-redis-介绍" data-v-b57cc07c>1. Redis 介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-redis-安装" class="sidebar-link reco-side-_2-redis-安装" data-v-b57cc07c>2.Redis 安装</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-spring-boot-集成-redis" class="sidebar-link reco-side-_3-spring-boot-集成-redis" data-v-b57cc07c>3. Spring Boot 集成 Redis</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-1-依赖导入" class="sidebar-link reco-side-_3-1-依赖导入" data-v-b57cc07c>3.1 依赖导入</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-2-redis-配置" class="sidebar-link reco-side-_3-2-redis-配置" data-v-b57cc07c>3.2 Redis 配置</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-3-常用-api-介绍" class="sidebar-link reco-side-_3-3-常用-api-介绍" data-v-b57cc07c>3.3 常用 api 介绍</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-redistemplate-和-stringredistemplate" class="sidebar-link reco-side-_4-redistemplate-和-stringredistemplate" data-v-b57cc07c>4.redisTemplate 和 stringRedisTemplate</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-总结-5" class="sidebar-link reco-side-_5-总结-5" data-v-b57cc07c>5. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-shiro-三大核心组件" class="sidebar-link reco-side-_1-shiro-三大核心组件" data-v-b57cc07c>1. Shiro 三大核心组件</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-shiro-身份和权限认证" class="sidebar-link reco-side-_1-shiro-身份和权限认证" data-v-b57cc07c>1. Shiro 身份和权限认证</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-2-shiro-身份认证" class="sidebar-link reco-side-_1-2-shiro-身份认证" data-v-b57cc07c>1.2 Shiro 身份认证</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-3-shiro-权限认证" class="sidebar-link reco-side-_1-3-shiro-权限认证" data-v-b57cc07c>1.3 Shiro 权限认证</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-spring-boot-集成-shiro-过程" class="sidebar-link reco-side-_2-spring-boot-集成-shiro-过程" data-v-b57cc07c>2. Spring Boot 集成 Shiro 过程</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1-依赖导入-3" class="sidebar-link reco-side-_2-1-依赖导入-3" data-v-b57cc07c>2.1 依赖导入</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-数据库表数据初始化" class="sidebar-link reco-side-_2-2-数据库表数据初始化" data-v-b57cc07c>2.2 数据库表数据初始化</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2-自定义-realm" class="sidebar-link reco-side-_2-2-自定义-realm" data-v-b57cc07c>2.2 自定义 Realm</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-3-shiro-配置" class="sidebar-link reco-side-_2-3-shiro-配置" data-v-b57cc07c>2.3 Shiro 配置</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-4-使用-shiro-进行认证" class="sidebar-link reco-side-_2-4-使用-shiro-进行认证" data-v-b57cc07c>2.4 使用 Shiro 进行认证</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-总结-3" class="sidebar-link reco-side-_3-总结-3" data-v-b57cc07c>3. 总结</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-简介" class="sidebar-link reco-side-_1-简介" data-v-b57cc07c>1.简介</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-特性" class="sidebar-link reco-side-_2-特性" data-v-b57cc07c>2.特性</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-入门" class="sidebar-link reco-side-_3-入门" data-v-b57cc07c>3.入门</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-mp-实现crud" class="sidebar-link reco-side-_4-mp-实现crud" data-v-b57cc07c>4. mp 实现crud</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-条件构造器-wrapper" class="sidebar-link reco-side-_5-条件构造器-wrapper" data-v-b57cc07c>5.条件构造器-wrapper</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-1wrapper介绍" class="sidebar-link reco-side-_5-1wrapper介绍" data-v-b57cc07c>5.1wrapper介绍</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-2abstractwrapper" class="sidebar-link reco-side-_5-2abstractwrapper" data-v-b57cc07c>5.2AbstractWrapper</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-概述" class="sidebar-link reco-side-_1-概述" data-v-b57cc07c>1.概述</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-整合步骤" class="sidebar-link reco-side-_2-整合步骤" data-v-b57cc07c>2.整合步骤</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-1引入依赖" class="sidebar-link reco-side-_2-1引入依赖" data-v-b57cc07c>2.1引入依赖</a></li><li class="level-3" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-2配置文件" class="sidebar-link reco-side-_2-2配置文件" data-v-b57cc07c>2.2配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-分布式锁" class="sidebar-link reco-side-_3-分布式锁" data-v-b57cc07c>3.分布式锁</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-导入依赖" class="sidebar-link reco-side-_1-导入依赖" data-v-b57cc07c>1.导入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-配置视图解析器" class="sidebar-link reco-side-_2-配置视图解析器" data-v-b57cc07c>2.配置视图解析器</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-创建webapp目录等" class="sidebar-link reco-side-_3-创建webapp目录等" data-v-b57cc07c>3.创建webapp目录等</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_1-统一的数据封装" class="sidebar-link reco-side-_1-统一的数据封装" data-v-b57cc07c>1. 统一的数据封装</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_2-json的处理" class="sidebar-link reco-side-_2-json的处理" data-v-b57cc07c>2. json的处理</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_3-swagger2在线可调式接口" class="sidebar-link reco-side-_3-swagger2在线可调式接口" data-v-b57cc07c>3. swagger2在线可调式接口</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_4-持久层集成" class="sidebar-link reco-side-_4-持久层集成" data-v-b57cc07c>4. 持久层集成</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_5-拦截器" class="sidebar-link reco-side-_5-拦截器" data-v-b57cc07c>5. 拦截器</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_6-全局异常处理" class="sidebar-link reco-side-_6-全局异常处理" data-v-b57cc07c>6. 全局异常处理</a></li><li class="level-2" data-v-b57cc07c><a href="/java/part3/springboot.html#_7-总结" class="sidebar-link reco-side-_7-总结" data-v-b57cc07c>7. 总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/assets/js/app.cf24e5c2.js" defer></script><script src="/assets/js/3.96e6e8dc.js" defer></script><script src="/assets/js/1.9cd0fbb8.js" defer></script><script src="/assets/js/24.93bb133f.js" defer></script>
  </body>
</html>
